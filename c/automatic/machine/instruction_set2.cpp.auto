static void spcfn__add( void ) {
    Ref ry = *( VMVP-- );
    Ref rx = *( VMVP );
    if ( IsSmall( rx ) && IsSmall( ry ) ) {
    	long y = (long)ry;
    	long x = (long)rx;
    	long sum = x + y;
    	if ( x < 0 ? sum <= y : sum >= y ) {
    		*VMVP = ToRef( sum );
    		RETURN( pc + 1 );
    	} else {
        	throw Mishap( "Overflow detected in +" );
    	}
    } else {
    	throw Mishap( "Small integers only" );
    } 
}

static void spcfn__decr( void ) {
    Ref rx = *VMVP;
    if ( IsSmall( rx ) ) {
    	long x = (long)rx;
    	long sum = x - (long)LongToSmall( 1 );
    	if ( sum > x ) {
    		throw Mishap( "integer overflow detected in x - 1" ).culprit( "x", "" + x );
    	}
    	*( VMVP ) = ToRef( sum );
    	RETURN( pc + 1 );
    } else {
    	throw Mishap( "Small integer needed" );
    }
    
    //*( VMVP ) = ToRef( ToLong( *( VMVP ) ) - ToLong( IntToSmall( 1 ) ) );
    //RETURN( pc + 1 );
}

static void spcfn__div( void ) {
    long b = ToLong( *( VMVP-- ) );
    *( VMVP ) = ToRef( ToLong( *( VMVP ) ) / b );
    RETURN( pc + 1 );
}

static void spcfn__eq( void ) {
    Ref r = *( VMVP-- );
    *( VMVP ) = *( VMVP ) == r ? sys_true : sys_false;
    RETURN( pc + 1 );
}

static void spcfn__neq( void ) {
    Ref r = *( VMVP-- );
    *( VMVP ) = *( VMVP ) == r ? sys_false : sys_true;
    RETURN( pc + 1 );
}

static void spcfn__gt( void ) {
    long b = ToLong( *( VMVP-- ) );
    *( VMVP ) = ToLong( *( VMVP ) ) > b ? sys_true : sys_false;
    RETURN( pc + 1 );
}

static void spcfn__gte( void ) {
    long b = ToLong( *( VMVP-- ) );
    *( VMVP ) = ToLong( *( VMVP ) ) >= b ? sys_true : sys_false;
    RETURN( pc + 1 );
}

static void spcfn__incr( void ) {
    Ref rx = *VMVP;
    if ( IsSmall( rx ) ) {
    	long x = (long)rx;
    	long sum = x + (long)LongToSmall( 1 );
    	if ( sum > x ) {
    		*( VMVP ) = ToRef( sum );
    		RETURN( pc + 1 );
    	} else {
    		throw Mishap( "integer overflow detected in x + 1" );
    	}
    } else {
    	throw Mishap( "Small integer needed" );
    }
    
}

static void spcfn__incr_by( void ) {
    Ref ry = ToRef( pc[ 1 ] );
    Ref rx = *( VMVP );
    if ( IsSmall( rx ) && IsSmall( ry ) ) {
    	long y = (long)ry;
    	long x = (long)rx;
    	long sum = x + y;
    	if ( x < 0 ? sum <= y : sum >= y ) {
    		*VMVP = ToRef( sum );
    		RETURN( pc + 2 );
    	} else {
        	throw Mishap( "Overflow detected in +" );
    	}
    } else {
    	throw Mishap( "Small integers only" );
    } 
}

static void spcfn__lt( void ) {
    long b = ToLong( *( VMVP-- ) );
    *( VMVP ) = ToLong( *( VMVP ) ) < b ? sys_true : sys_false;
    RETURN( pc + 1 );
}

static void spcfn__lte( void ) {
    long b = ToLong( *( VMVP-- ) );
    *( VMVP ) = ToLong( *( VMVP ) ) <= b ? sys_true : sys_false;
    RETURN( pc + 1 );
}

static void spcfn__mul( void ) {
    //  This needs to be given overflow detection!
    long b = ToLong( *( VMVP-- ) );
    *( VMVP ) = ToRef( ToLong( *( VMVP ) ) * ( b >> TAG ) );
    RETURN( pc + 1 );
}

static void spcfn__sub( void ) {
    //  This needs to be given overflow detection!
    long b = ToLong( *( VMVP-- ) );
    *( VMVP ) = ToRef( ToLong( *( VMVP ) ) - b );
    RETURN( pc + 1 );
}

static void spcfn_calls( void ) {
    Ref r = *( VMVP-- );
    {    
        Ref *ptr;
        if ( !IsObj( r ) ) call_error( r );
        ptr = RefToPtr4( r );
        if ( !IsFunction( *ptr ) ) call_error( r );
        VMLINK = pc + 1;
        VMLINKFUNC = VMPCFUNC;
        VMPCFUNC = ptr;
        RETURN( ptr + 1 );
    }
}

static void spcfn_check0( void ) {
    long n = ToLong( *( ++pc ) );
    #ifdef DBG_SPECIAL
    fprintf(
    	stderr,
    	"Difference between %lu and %lu (held in %ld)\n",
    	ToULong( VMVP ),
    	ToULong( LOCAL(n) ),
    	n
    );
    #endif
    if ( VMVP == LOCAL(n) ) RETURN( pc + 1 );
    throw Mishap( "Wrong number of results (needed 0)" ).culprit( "#Results", "" + ( VMVP - ToRefRef( LOCAL(n) ) ) );
    RETURN( NULL );	// stupid compiler
}

static void spcfn_check1( void ) {
    long n = ToLong( *( ++pc ) );
    unsigned long d;
    #ifdef DBG_SPECIAL
    fprintf( stderr, "Recovering %lu from %ld\n", ToULong( LOCAL(n) ), n );
    fprintf( stderr, "Comparing with %u\n",  ToULong( VMVP ) );
    fprintf( stderr, "Length of value stack = %d\n", ( VMVP - VMVP_base ) );
    #endif
    d = VMVP - ToRefRef( LOCAL(n) );
    if ( d == 1 ) RETURN( pc + 1 );
    throw Mishap( "Wrong number of results (needed 1)" ).culprit( "#results", "" + d );
    RETURN( NULL );	// stupid compiler
}

static void spcfn_end( void ) {
    Ref r;
    long n = ToLong( *( ++pc ) );
    #ifdef DBG_SPECIAL
    fprintf( stderr, "Recovering %u from %d\n", ToULong( LOCAL(n) ), n );
    fprintf( stderr, "Comparing with %u\n",  ToULong( VMVP ) );
    fprintf( stderr, "Length of value stack = %d\n", ( VMVP - VMVP_base ) );
    #endif
    r = ToRef( ToULong( VMVP ) - ToULong( LOCAL(n) ) );
    *( ++VMVP ) = r;
    RETURN( pc + 1 );
}

static void spcfn_end1_calls( void ) {
    Ref r = *( VMVP-- );
    long var = ToLong( pc[ 1 ] );
    VMCOUNT = ( VMVP - ToRefRef( LOCAL( var ) ) ) - 1;
    {    
        Ref *ptr;
        if ( !IsObj( r ) ) call_error( r );
        ptr = RefToPtr4( r );
        if ( !IsFunction( *ptr ) ) call_error( r );
        VMLINK = pc + 2;
        VMLINKFUNC = VMPCFUNC;
        VMPCFUNC = ptr;
        RETURN( ptr + 1 );
    }
}

static void spcfn_end_call_global( void ) {
    long var = ToLong( pc[ 1 ] );
    Ref r = ((IdentClass *)( pc[ 2 ] )) -> valof;
    VMCOUNT = VMVP - ToRefRef( LOCAL( var ) );
    {    
        Ref *ptr;
        if ( !IsObj( r ) ) call_error( r );
        ptr = RefToPtr4( r );
        if ( !IsFunction( *ptr ) ) call_error( r );
        VMLINK = pc + 3;
        VMLINKFUNC = VMPCFUNC;
    	VMPCFUNC = ptr;
        RETURN( ptr + 1 );
    }
}

static void spcfn_enter( void ) {
    long A = ToLong( pc[ -2 ] ); // field before the function key.
    Ref *prev = VMSP;
    VMSP -= SP_OVERHEAD + ToULong( pc[ -3 ] );
    VMSP[ SP_PREV_SP ] = prev;
    VMSP[ SP_LINK ] = VMLINK;
    VMSP[ SP_FUNC ] = VMLINKFUNC;
    if ( A != VMCOUNT ) {
        enter_error( VMCOUNT, A );
    }
    {
        while ( --A >= 0 ) {
            LOCAL( A ) = *( VMVP-- );
        }
    }
    RETURN( pc + 1 );
}

static void spcfn_enter0( void ) {
    Ref *prev = VMSP;
    VMSP -= SP_OVERHEAD + ToULong( pc[ -3 ] );
    VMSP[ SP_PREV_SP ] = prev;
    VMSP[ SP_LINK ] = VMLINK;
    VMSP[ SP_FUNC ] = VMLINKFUNC;
    if ( VMCOUNT != 0 ) {
        enter_error( VMCOUNT, 0 );
    }
    RETURN( pc + 1 );
}

static void spcfn_enter1( void ) {
    Ref *prev = VMSP;
    VMSP -= SP_OVERHEAD + ToULong( pc[ -3 ] );
    VMSP[ SP_PREV_SP ] = prev;
    VMSP[ SP_LINK ] = VMLINK;
    VMSP[ SP_FUNC ] = VMLINKFUNC;
    if ( VMCOUNT != 1 ) {
        enter_error( VMCOUNT, 1 );
    }
    LOCAL( 0 ) = *( VMVP-- );
    RETURN( pc + 1 );
}

static void spcfn_eq_si( void ) {
    long s = ToLong( pc[1] );
    long i = ToLong( pc[2] );
    long d = ToLong( pc[3] );
    RETURN( ToLong( LOCAL( s ) ) == i ? pc + d + 3 : pc + 4 );
}

static void spcfn_eq_ss( void ) {
    long s = ToLong( pc[1] );
    long t = ToLong( pc[2] );
    long d = ToLong( pc[3] );
    RETURN( ToLong( LOCAL( s ) ) == ToLong( LOCAL( t ) ) ? pc + d + 3 : pc + 4 );
}

static void spcfn_goto( void ) {
    long n = ToLong( *( ++pc ) );
    RETURN( pc + n );
}

static void spcfn_gt_si( void ) {
    long s = ToLong( pc[1] );
    long i = ToLong( pc[2] );
    RETURN( ToLong( LOCAL( s ) ) > i ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
}

static void spcfn_gt_ss( void ) {
    long s = ToLong( pc[1] );
    long t = ToLong( pc[2] );
    long d = ToLong( pc[3] );
    RETURN( ToLong( LOCAL( s ) ) > ToLong( LOCAL( t ) ) ? pc + d + 3 : pc + 4 );
}

static void spcfn_gte_si( void ) {
    long s = ToLong( pc[1] );
    long i = ToLong( pc[2] );
    long d = ToLong( pc[3] );
    RETURN( ToLong( LOCAL( s ) ) >= i ? pc + d + 3: pc + 4 );
}

static void spcfn_gte_ss( void ) {
    long s = ToLong( pc[1] );
    long t = ToLong( pc[2] );
    long d = ToLong( pc[3] );
    RETURN( ToLong( LOCAL( s ) ) >= ToLong( LOCAL( t ) ) ? pc + d + 3 : pc + 4 );
}

static void spcfn_halt( void ) {
    #ifdef DBG_SPECIAL	
    printf( "\nhalt\n" );
    #endif
    exit( EXIT_SUCCESS );
}

static void spcfn_ifnot( void ) {
    #ifdef DBG_SPECIAL
    fprintf( stderr, "IFNOT finds %x on the stack (cf. %x & %x)\n", (unt)(*( VMVP )), (unt)(sys_false), (unt)(sys_true) );
    #endif
    RETURN(
    	*( VMVP-- ) == sys_false ?
    	pc + ToLong( pc[ 1 ] ) + 1:
    	pc + 2
    );
}

static void spcfn_ifso( void ) {
    RETURN(
    	*( VMVP-- ) == sys_false ?
    	pc + 2 :
    	pc + ToLong( pc[ 1 ] ) + 1
    );
}

static void spcfn_lt_si( void ) {
    long s = ToLong( pc[1] );
    long i = ToLong( pc[2] );
    long d = ToLong( pc[3] );
    RETURN( ToLong( LOCAL( s ) ) < i ? pc + d + 3 : pc + 4 );
}

static void spcfn_lt_ss( void ) {
    long s = ToLong( pc[1] );
    long t = ToLong( pc[2] );
    long d = ToLong( pc[3] );
    RETURN( ToLong( LOCAL( s ) ) < ToLong( LOCAL( t ) ) ? pc + d + 3 : pc + 4 );
}

static void spcfn_lte_si( void ) {
    long s = ToLong( pc[1] );
    long i = ToLong( pc[2] );
    long d = ToLong( pc[3] );
    RETURN( ToLong( LOCAL( s ) ) <= i ? pc + d + 3 : pc + 4 );
}

static void spcfn_lte_ss( void ) {
    long s = ToLong( pc[1] );
    long t = ToLong( pc[2] );
    long d = ToLong( pc[3] );
    RETURN( ToLong( LOCAL( s ) ) <= ToLong( LOCAL( t ) ) ? pc + d + 3 : pc + 4 );
}

static void spcfn_neq_si( void ) {
    long s = ToLong( pc[1] );
    long i = ToLong( pc[2] );
    RETURN( ToLong( LOCAL( s ) ) == i ? pc + 4 : pc + ToLong( pc[3] ) + 3 );
}

static void spcfn_neq_ss( void ) {
    long s = ToLong( pc[1] );
    long t = ToLong( pc[2] );
    long d = ToLong( pc[3] );
    RETURN( ToLong( LOCAL( s ) ) != ToLong( LOCAL( t ) ) ? pc + d + 3 : pc + 4 );
}

static void spcfn_not( void ) {
    *VMVP = ( *VMVP == sys_false ? sys_true : sys_false );
    RETURN( pc + 1 );
}

static void spcfn_pop_global( void ) {
    IdentClass * id = (IdentClass *)( *( ++pc ) );
    id->valof = *( VMVP-- );
    RETURN( pc + 1 );
}

static void spcfn_pop_local( void ) {
    LOCAL( ToLong( *( ++pc ) ) ) = *( VMVP-- );
    RETURN( pc + 1 );
}

static void spcfn_push_global( void ) {
    IdentClass * id = (IdentClass *)( *( ++pc ) );
    *( ++VMVP ) = id->valof;
    RETURN( pc + 1 );
}

static void spcfn_push_local( void ) {
    *( ++VMVP ) = LOCAL( ToLong( *( ++pc ) ) );
    RETURN( pc + 1 );
}

static void spcfn_push_local0( void ) {
    *( ++VMVP ) = LOCAL(0);
    RETURN( pc + 1 );
}

static void spcfn_push_local1( void ) {
    *( ++VMVP ) = LOCAL(1);
    RETURN( pc + 1 );
}

static void spcfn_pushq( void ) {
    *( ++VMVP ) = *( ++pc );
    RETURN( pc + 1 );
}

static void spcfn_reset( void ) {
    FREEZE;
    throw NormalExit();
}

static void spcfn_return( void ) {
    Ref *linkptr;
    VMPCFUNC = ToRefRef( VMSP[ SP_FUNC ] );
    linkptr = ToRefRef( VMSP[ SP_LINK ] );				//	recover return address
    VMSP = ToRefRef( VMSP[ SP_PREV_SP ] );				//	restore stack pointer
    #ifdef DBG_SPECIAL
    	printf( "Recover link = %x\n", ToUInt( link ) );
    	printf( "Stack pointer recovered as %x\n", ToUInt( VMSP ) );
    #endif
    RETURN( linkptr );
}

static void spcfn_set( void ) {
    VMCOUNT = VMVP - (Ref *)LOCAL( ToLong( pc[ 1 ] ) );
    RETURN( pc + 2 );
}

static void spcfn_set_call_global( void ) {
    Ref r = ((IdentClass *)( pc[ 2 ] )) -> valof;
    VMCOUNT = ToLong( pc[ 1 ] );
    {    
        Ref *ptr;
        if ( !IsObj( r ) ) call_error( r );
        ptr = RefToPtr4( r );
        if ( !IsFunction( *ptr ) ) call_error( r );
        VMLINK = pc + 3;
        VMLINKFUNC = VMPCFUNC;
    	VMPCFUNC = ptr;
        RETURN( ptr + 1 );
    }
}

static void spcfn_set_calls( void ) {
    Ref r = *( VMVP-- );
    VMCOUNT = ToLong( pc[ 1 ] );
    {    
        Ref *ptr;
        if ( !IsObj( r ) ) call_error( r );
        ptr = RefToPtr4( r );
        if ( !IsFunction( *ptr ) ) call_error( r );
        VMLINK = pc + 2;
        VMLINKFUNC = VMPCFUNC;
        VMPCFUNC = ptr;
        RETURN( ptr + 1 );
    }
}

static void spcfn_start( void ) {
    long n = ToLong( *( ++pc ) );
    #ifdef DBG_SPECIAL
    fprintf( stderr, "Storing %u in %d\n", ToULong( ToRef( VMVP ) ), n );
    #endif
    LOCAL(n) = ToRef( VMVP );
    RETURN( pc + 1 );
}

static void spcfn_syscall( void ) {
    SysCall * sys = ToSysCall( *++pc );
    FREEZE;
    pc = (*sys)( ++pc, vm );
    MELT;
    RETURN( pc );
}

static void spcfn_sysreturn( void ) {
    VMPCFUNC = VMLINKFUNC;
    RETURN( VMLINK );
}

InstructionSet2::InstructionSet2() {
    this->spc__add = (Ref)spcfn__add;
    this->spc__decr = (Ref)spcfn__decr;
    this->spc__div = (Ref)spcfn__div;
    this->spc__eq = (Ref)spcfn__eq;
    this->spc__neq = (Ref)spcfn__neq;
    this->spc__gt = (Ref)spcfn__gt;
    this->spc__gte = (Ref)spcfn__gte;
    this->spc__incr = (Ref)spcfn__incr;
    this->spc__incr_by = (Ref)spcfn__incr_by;
    this->spc__lt = (Ref)spcfn__lt;
    this->spc__lte = (Ref)spcfn__lte;
    this->spc__mul = (Ref)spcfn__mul;
    this->spc__sub = (Ref)spcfn__sub;
    this->spc_calls = (Ref)spcfn_calls;
    this->spc_check0 = (Ref)spcfn_check0;
    this->spc_check1 = (Ref)spcfn_check1;
    this->spc_end = (Ref)spcfn_end;
    this->spc_end1_calls = (Ref)spcfn_end1_calls;
    this->spc_end_call_global = (Ref)spcfn_end_call_global;
    this->spc_enter = (Ref)spcfn_enter;
    this->spc_enter0 = (Ref)spcfn_enter0;
    this->spc_enter1 = (Ref)spcfn_enter1;
    this->spc_eq_si = (Ref)spcfn_eq_si;
    this->spc_eq_ss = (Ref)spcfn_eq_ss;
    this->spc_goto = (Ref)spcfn_goto;
    this->spc_gt_si = (Ref)spcfn_gt_si;
    this->spc_gt_ss = (Ref)spcfn_gt_ss;
    this->spc_gte_si = (Ref)spcfn_gte_si;
    this->spc_gte_ss = (Ref)spcfn_gte_ss;
    this->spc_halt = (Ref)spcfn_halt;
    this->spc_ifnot = (Ref)spcfn_ifnot;
    this->spc_ifso = (Ref)spcfn_ifso;
    this->spc_lt_si = (Ref)spcfn_lt_si;
    this->spc_lt_ss = (Ref)spcfn_lt_ss;
    this->spc_lte_si = (Ref)spcfn_lte_si;
    this->spc_lte_ss = (Ref)spcfn_lte_ss;
    this->spc_neq_si = (Ref)spcfn_neq_si;
    this->spc_neq_ss = (Ref)spcfn_neq_ss;
    this->spc_not = (Ref)spcfn_not;
    this->spc_pop_global = (Ref)spcfn_pop_global;
    this->spc_pop_local = (Ref)spcfn_pop_local;
    this->spc_push_global = (Ref)spcfn_push_global;
    this->spc_push_local = (Ref)spcfn_push_local;
    this->spc_push_local0 = (Ref)spcfn_push_local0;
    this->spc_push_local1 = (Ref)spcfn_push_local1;
    this->spc_pushq = (Ref)spcfn_pushq;
    this->spc_reset = (Ref)spcfn_reset;
    this->spc_return = (Ref)spcfn_return;
    this->spc_set = (Ref)spcfn_set;
    this->spc_set_call_global = (Ref)spcfn_set_call_global;
    this->spc_set_calls = (Ref)spcfn_set_calls;
    this->spc_start = (Ref)spcfn_start;
    this->spc_syscall = (Ref)spcfn_syscall;
    this->spc_sysreturn = (Ref)spcfn_sysreturn;
}

