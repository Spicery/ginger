lnx2mnx - an extensible parser
===============================

Usage: lnx2mnx --grammar=FILENAME < SOURCE > GNX

A configurable parser that allows you to parse a variety of useful languages into MinX. The configuration would be done at runtime. The basic technology is a recursive descent parser with operator precedence and a generic lexer.

The grammar should define the reserved tokens and their lexical properties. This should include their role and precedence:

_WARNING: The rest of this file is hopelessly out of date_

--------------------------------------------------------------------------------
	<lex token="if" role="special"/>
	<lex token="then" role="nonfix"/>
	<lex token=";" role="infix" precedence="10"/>
--------------------------------------------------------------------------------

The grammar file should be written in GNX, naturally enough. It should support grammar rules that allow for very efficient deterministic parsing. Here's an example for parsing an "if" form.

--------------------------------------------------------------------------------
<!-- Code for the if-form -->
<form title="if-form">
	<lex token="if" role="special"/>
	<lex token="then" role="nonfix"/>
	<lex token="elseif" role="nonfix"/>
	<lex token="elseunless" role="nonfix"/>
	<lex token="endif" role="nonfix"/>
	
	<rule state="EXPR" on="if">
		<element name="if">
			<read state="EXPR"/>
			<read state="THEN"/>
		</element>
	</rule>
	<rule state="THEN" on="then">
		<read state="EXPR"/>
		<read state="ELSE"/>
	</rule>
	<rule state="ELSE" on="elseif">
		<read state="EXPR"/>
		<read state="THEN"/>
	</rule>
	<rule state="ELSE" on="elseunless">
		<element name="not"><read state="EXPR"/></element>
		<read state="THEN"/>
	</rule>
	<rule state="ELSE" on="endif">
		<element name="seq"/>
	</rule>
	<rule state="ELSE" on="else">
		<read state="EXPR"/>
		<must.read token="endif"/>
	</rule>
</form>
--------------------------------------------------------------------------------


The recursive descent can be defined like this.
--------------------------------------------------------------------------------
<form title="General Expression">
	<lex token="(" role="special"/>
	<lex token=")" role="nonfix"/>
	
	<rule state="EXPR">
		<read state="PRIMARY"/>
		<read state="SECONDARY"/>
	</rule>
	<rule state="PRIMARY" on="(">
		<if peek.role="nonfix">
			<element name="seq"/>
			<read state="EXPR"/>
		</if>
		<must.read token=")"/>
	</rule>
	<!-- Note we peek the open parenthesis so we can just reuse EXPR -->
	<rule state="SECONDARY" peek="(">
		<!-- Save the LHS to the scratchpad -->
		<save/>
		<element name="app">
			<!-- Recover the LHS as the function -->
			<restore/>
			<read state="EXPR"/>
		</element>
	</rule>
</form>

--------------------------------------------------------------------------------


The following rule would serve for parsing normal identifiers.
--------------------------------------------------------------------------------
<form title="id">
	<rule state="PRIMARY" role="unreserved">
		<element name="id">
			<!-- We have to get access to the current token. -->
			<put key="name" value.from="token"/>
		</element>
	</rule>
</form>
--------------------------------------------------------------------------------

How does precedence work? Every *read* has a state and a precedence. But default the precedence is 0. A continuation rule may have an associated precedence; if the current precedence is too high, the rule cannot be taken.

Here's an example showing how one defines infix operators.
--------------------------------------------------------------------------------
<form title="+ operator>
	<lex token="+" role="infix" precedence="1000"/>
	<lex token="," role="infix" precedence="100"/>
	<rule state="SECONDARY" role="infix" precedence.from="token">
		<!-- 
			We have to get access to the left hand side. 
			Save it to the scratchpad.
		-->
		<save/> 
		<element name="sysapp">
			<put key="name" from "token"/>
			<seq>
				<!-- Grab LHS from the scratchpad -->
				<restore/>
				<read state="EXPR" precedence.from="token"/>
			</seq>
		</element>
	</rule>
</form>
--------------------------------------------------------------------------------
