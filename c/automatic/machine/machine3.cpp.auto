void Machine3::core( bool init_mode, Ref *pc ) {
    Ref *VMSP, *VMVP, *VMLINK;
    if ( init_mode ) goto Initialize;
    MELT;
    goto **pc;
    L_add: {
        Ref ry = *( VMVP-- );
        Ref rx = *( VMVP );
        if ( IsSmall( rx ) && IsSmall( ry ) ) {
        	long y = (long)ry;
        	long x = (long)rx;
        	long sum = x + y;
        	if ( x < 0 ? sum <= y : sum >= y ) {
        		*VMVP = ToRef( sum );
        		RETURN( pc + 1 );
        	} else {
            	throw Mishap( "Overflow detected in +" );
        	}
        } else {
        	throw Mishap( "Small integers only" );
        } 
    }
    L_decr: {
        Ref rx = *VMVP;
        if ( IsSmall( rx ) ) {
        	long x = (long)rx;
        	long sum = x - (long)LongToSmall( 1 );
        	if ( sum > x ) {
        		throw Mishap( "integer overflow detected in x - 1" ).culprit( "x", "" + x );
        	}
        	*( VMVP ) = ToRef( sum );
        	RETURN( pc + 1 );
        } else {
        	throw Mishap( "Small integer needed" );
        }
        
        //*( VMVP ) = ToRef( ToLong( *( VMVP ) ) - ToLong( IntToSmall( 1 ) ) );
        //RETURN( pc + 1 );
    }
    L_div: {
        long b = ToLong( *( VMVP-- ) );
        *( VMVP ) = ToRef( ToLong( *( VMVP ) ) / b );
        RETURN( pc + 1 );
    }
    L_eq: {
        Ref r = *( VMVP-- );
        *( VMVP ) = *( VMVP ) == r ? sys_true : sys_false;
        RETURN( pc + 1 );
    }
    L_neq: {
        Ref r = *( VMVP-- );
        *( VMVP ) = *( VMVP ) == r ? sys_false : sys_true;
        RETURN( pc + 1 );
    }
    L_gt: {
        long b = ToLong( *( VMVP-- ) );
        *( VMVP ) = ToLong( *( VMVP ) ) > b ? sys_true : sys_false;
        RETURN( pc + 1 );
    }
    L_gte: {
        long b = ToLong( *( VMVP-- ) );
        *( VMVP ) = ToLong( *( VMVP ) ) >= b ? sys_true : sys_false;
        RETURN( pc + 1 );
    }
    L_incr: {
        Ref rx = *VMVP;
        if ( IsSmall( rx ) ) {
        	long x = (long)rx;
        	long sum = x + (long)LongToSmall( 1 );
        	if ( sum > x ) {
        		*( VMVP ) = ToRef( sum );
        		RETURN( pc + 1 );
        	} else {
        		throw Mishap( "integer overflow detected in x + 1" );
        	}
        } else {
        	throw Mishap( "Small integer needed" );
        }
        
    }
    L_incr_by: {
        Ref ry = ToRef( pc[ 1 ] );
        Ref rx = *( VMVP );
        if ( IsSmall( rx ) && IsSmall( ry ) ) {
        	long y = (long)ry;
        	long x = (long)rx;
        	long sum = x + y;
        	if ( x < 0 ? sum <= y : sum >= y ) {
        		*VMVP = ToRef( sum );
        		RETURN( pc + 2 );
        	} else {
            	throw Mishap( "Overflow detected in +" );
        	}
        } else {
        	throw Mishap( "Small integers only" );
        } 
    }
    L_lt: {
        long b = ToLong( *( VMVP-- ) );
        *( VMVP ) = ToLong( *( VMVP ) ) < b ? sys_true : sys_false;
        RETURN( pc + 1 );
    }
    L_lte: {
        long b = ToLong( *( VMVP-- ) );
        *( VMVP ) = ToLong( *( VMVP ) ) <= b ? sys_true : sys_false;
        RETURN( pc + 1 );
    }
    L_mul: {
        //  This needs to be given overflow detection!
        long b = ToLong( *( VMVP-- ) );
        *( VMVP ) = ToRef( ToLong( *( VMVP ) ) * ( b >> TAG ) );
        RETURN( pc + 1 );
    }
    L_sub: {
        //  This needs to be given overflow detection!
        long b = ToLong( *( VMVP-- ) );
        *( VMVP ) = ToRef( ToLong( *( VMVP ) ) - b );
        RETURN( pc + 1 );
    }
    L_calls: {
        Ref r = *( VMVP-- );
        {    
            Ref *ptr;
            if ( !IsObj( r ) ) call_error( r );
            ptr = RefToPtr4( r );
            if ( !IsFunctionKey( *ptr ) ) call_error( r );
            VMLINK = pc + 1;
            VMLINKFUNC = VMPCFUNC;
            VMPCFUNC = ptr;
            RETURN( ptr + 1 );
        }
    }
    L_chainlite: {
        Ref * fn_K = RefToPtr4( pc[ 1 ] );
        VMCOUNT += ToLong( pc[2] );
        
        //	Leave VMLINK & VMLINKFUNC alone.
        //	The lite function has not stashed them into the callstack.
        //	As a consequence we can chain directly without meddling with
        //	them.
        
        VMPCFUNC = fn_K;
        RETURN( fn_K + 1 );
    }
    L_check_count: {
        long n = ToLong( *( ++pc ) );
        #ifdef DBG_SPECIAL
        fprintf(
        	stderr,
        	"Difference between %lu and %lu (held in %ld)\n",
        	ToULong( VMVP ),
        	ToULong( LOCAL(n) ),
        	n
        );
        #endif
        if ( VMCOUNT == n ) RETURN( pc + 1 );
        throw Mishap( "Wrong number of results (needed 0)" ).culprit( "#Results", "" + ( VMVP - ToRefRef( LOCAL(n) ) ) );
        RETURN( NULL );	// stupid compiler
    }
    L_check_mark0: {
        long n = ToLong( *( ++pc ) );
        #ifdef DBG_SPECIAL
        fprintf(
        	stderr,
        	"Difference between %lu and %lu (held in %ld)\n",
        	ToULong( VMVP ),
        	ToULong( LOCAL(n) ),
        	n
        );
        #endif
        if ( VMVP == LOCAL(n) ) RETURN( pc + 1 );
        throw Mishap( "Wrong number of results (needed 0)" ).culprit( "#Results", "" + ( VMVP - ToRefRef( LOCAL(n) ) ) );
        RETURN( NULL );	// stupid compiler
    }
    L_check_mark1: {
        long n = ToLong( *( ++pc ) );
        unsigned long d;
        #ifdef DBG_SPECIAL
        fprintf( stderr, "Recovering %lu from %ld\n", ToULong( LOCAL(n) ), n );
        fprintf( stderr, "Comparing with %u\n",  ToULong( VMVP ) );
        fprintf( stderr, "Length of value stack = %d\n", ( VMVP - VMVP_base ) );
        #endif
        d = VMVP - ToRefRef( LOCAL(n) );
        if ( d == 1 ) RETURN( pc + 1 );
        throw Mishap( "Wrong number of results (needed 1)" ).culprit( "#results", "" + d );
        RETURN( NULL );	// stupid compiler
    }
    L_end_mark: {
        Ref r;
        long n = ToLong( *( ++pc ) );
        #ifdef DBG_SPECIAL
        fprintf( stderr, "Recovering %u from %d\n", ToULong( LOCAL(n) ), n );
        fprintf( stderr, "Comparing with %u\n",  ToULong( VMVP ) );
        fprintf( stderr, "Length of value stack = %d\n", ( VMVP - VMVP_base ) );
        #endif
        r = ToRef( ToULong( VMVP ) - ToULong( LOCAL(n) ) );
        *( ++VMVP ) = r;
        RETURN( pc + 1 );
    }
    L_end1_calls: {
        Ref r = *( VMVP-- );							//	Reduce stack by 1, safely.
        long var = ToLong( pc[ 1 ] );
        VMCOUNT = ( VMVP - ToRefRef( LOCAL( var ) ) );	//	Stack reduced by 1 already, don't redo.
        {    
            Ref *ptr;
            if ( !IsObj( r ) ) call_error( r );
            ptr = RefToPtr4( r );
            if ( !IsFunctionKey( *ptr ) ) call_error( r );
            VMLINK = pc + 2;
            VMLINKFUNC = VMPCFUNC;
            VMPCFUNC = ptr;
            RETURN( ptr + 1 );
        }
    }
    L_end_call_global: {
        long var = ToLong( pc[ 1 ] );
        Ref r = ((Valof *)( pc[ 2 ] )) -> valof;
        VMCOUNT = VMVP - ToRefRef( LOCAL( var ) );
        {    
            Ref *ptr;
            if ( !IsObj( r ) ) call_error( r );
            ptr = RefToPtr4( r );
            if ( !IsFunctionKey( *ptr ) ) call_error( r );
            VMLINK = pc + 3;
            VMLINKFUNC = VMPCFUNC;
        	VMPCFUNC = ptr;
            RETURN( ptr + 1 );
        }
    }
    L_enter: {
        //
        //	ENTER only works as the 1st instruction of a function.
        //	It uses -ve offsets to access the fields before the key.
        //
        long A = ToLong( pc[ -2 ] ); // field before the function key.
        Ref *prev = VMSP;
        VMSP -= SP_OVERHEAD + ToULong( pc[ -3 ] );
        VMSP[ SP_PREV_SP ] = prev;
        VMSP[ SP_LINK ] = VMLINK;
        VMSP[ SP_FUNC ] = VMLINKFUNC;
        if ( A != VMCOUNT ) {
            enter_error( VMCOUNT, A );
        }
        {
            while ( --A >= 0 ) {
                LOCAL( A ) = *( VMVP-- );
            }
        }
        RETURN( pc + 1 );
    }
    L_enter0: {
        //	ENTER0 only works as the 1st instruction of a function.
        Ref *prev = VMSP;
        VMSP -= SP_OVERHEAD + ToULong( pc[ -3 ] );
        VMSP[ SP_PREV_SP ] = prev;
        VMSP[ SP_LINK ] = VMLINK;
        VMSP[ SP_FUNC ] = VMLINKFUNC;
        if ( VMCOUNT != 0 ) {
            enter_error( VMCOUNT, 0 );
        }
        RETURN( pc + 1 );
    }
    L_enter1: {
        //	ENTER1 only works as the 1st instruction of a function.
        Ref *prev = VMSP;
        VMSP -= SP_OVERHEAD + ToULong( pc[ -3 ] );
        VMSP[ SP_PREV_SP ] = prev;
        VMSP[ SP_LINK ] = VMLINK;
        VMSP[ SP_FUNC ] = VMLINKFUNC;
        if ( VMCOUNT != 1 ) {
            enter_error( VMCOUNT, 1 );
        }
        LOCAL( 0 ) = *( VMVP-- );
        RETURN( pc + 1 );
    }
    L_eq_si: {
        long s = ToLong( pc[1] );
        long i = ToLong( pc[2] );
        long d = ToLong( pc[3] );
        RETURN( ToLong( LOCAL( s ) ) == i ? pc + d + 3 : pc + 4 );
    }
    L_eq_ss: {
        long s = ToLong( pc[1] );
        long t = ToLong( pc[2] );
        long d = ToLong( pc[3] );
        RETURN( ToLong( LOCAL( s ) ) == ToLong( LOCAL( t ) ) ? pc + d + 3 : pc + 4 );
    }
    L_field: {
        unsigned long N = ToULong( *++pc );
        VMVP[0] = RefToPtr4( VMVP[0] )[ N ];
        RETURN( pc + 1 );
    }
    L_getiterator: {
        FREEZE;
        pc = sysFastGetFastIterator( pc, vm );
        MELT;
        RETURN( pc + 1 );
    }
    L_goto: {
        long n = ToLong( *( ++pc ) );
        RETURN( pc + n );
    }
    L_gt_si: {
        long s = ToLong( pc[1] );
        long i = ToLong( pc[2] );
        RETURN( ToLong( LOCAL( s ) ) > i ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
    }
    L_gt_ss: {
        long s = ToLong( pc[1] );
        long t = ToLong( pc[2] );
        long d = ToLong( pc[3] );
        RETURN( ToLong( LOCAL( s ) ) > ToLong( LOCAL( t ) ) ? pc + d + 3 : pc + 4 );
    }
    L_gte_si: {
        long s = ToLong( pc[1] );
        long i = ToLong( pc[2] );
        long d = ToLong( pc[3] );
        RETURN( ToLong( LOCAL( s ) ) >= i ? pc + d + 3: pc + 4 );
    }
    L_gte_ss: {
        long s = ToLong( pc[1] );
        long t = ToLong( pc[2] );
        long d = ToLong( pc[3] );
        RETURN( ToLong( LOCAL( s ) ) >= ToLong( LOCAL( t ) ) ? pc + d + 3 : pc + 4 );
    }
    L_halt: {
        #ifdef DBG_SPECIAL	
        printf( "\nhalt\n" );
        #endif
        exit( EXIT_SUCCESS );
    }
    L_ifnot: {
        #ifdef DBG_SPECIAL
        fprintf( stderr, "IFNOT finds %x on the stack (cf. %x & %x)\n", (unt)(*( VMVP )), (unt)(sys_false), (unt)(sys_true) );
        #endif
        RETURN(
        	*( VMVP-- ) == sys_false ?
        	pc + ToLong( pc[ 1 ] ) + 1:
        	pc + 2
        );
    }
    L_ifso: {
        RETURN(
        	*( VMVP-- ) == sys_false ?
        	pc + 2 :
        	pc + ToLong( pc[ 1 ] ) + 1
        );
    }
    L_invoke: {
        //
        //	INVOKE only works as the 1st instruction of a function.
        //	It uses -ve offsets to access the fields before the key.
        //
        //	The purpose of INVOKE is to dispatch a core method on an
        //	object and its arguments.
        //
        
        //	Get the arity from the field before the function key.
        long A = ToLong( pc[ -2 ] );
        //	Check the arguments.
        if ( VMCOUNT != A ) {
        	enter_error( VMCOUNT, A );
        }
        
        //	Get the subject.
        Ref subject = VMVP[ A - 1 ];
        
        //	Get the method.
        Ref method = Ptr4ToRef( pc - 1 );	//	Self pointer (tagged) !!!!
        		
        //	Select the method fragment to call.
        if ( IsObj( subject ) ) {
        	Ref * subject_K = RefToPtr4( subject );
        	Ref key = subject_K[ 0 ];
        	
        	//	Does the method cache contain this key?
        	{
        		Ref method_table = pc[ 1 ];
        		while ( method_table != sys_absent ) {
        			Ref * entry_K = RefToPtr4( method_table );
        			if ( key == entry_K[ ASSOC_KEY_OFFSET ] ) {
        				Ref fn = entry_K[ ASSOC_VALUE_OFFSET ];
        				//	Now chain out.
        				Ref * fn_K = RefToPtr4( fn );
        				VMPCFUNC = fn_K;
        				RETURN( fn_K + 1 );
        			}
        		}
        	}
        	
        	{
        		//	Ensure that there is enough room to add into the method
        		//	cache.
        		if ( vm->heap().wouldGC( ASSOC_SIZE ) ) {
        			vm->heap().preflight( pc, ASSOC_SIZE );
        			//	This will have trashed the local variables so we simply
        			//	retry! It's not efficient but it is exceedingly rare.
        			RETURN( pc );	//	<---- Loop!!
        		}
        	}
        	
        	//	Not in the method cache. Attempt to look it up in the object.
        	if ( IsObj( key ) ) {
        		Ref * key_K = RefToPtr4( key );	
        		Ref dispatch_table = key_K[ CLASS_OFFSET_DISPATCH_TABLE ];
        		while ( dispatch_table != sys_absent ) {
        			Ref * entry_K = RefToPtr4( dispatch_table );
        			if ( method == entry_K[ ASSOC_KEY_OFFSET ] ) {	
        				Ref fn = entry_K[ ASSOC_VALUE_OFFSET ];
        				
        				//	Add to the method cache.
        				{
        					vm->gcVeto();
        					XfrClass xfr( vm->heap().preflight( pc, ASSOC_SIZE ) );
        					xfr.setOrigin();
        					xfr.xfrRef( sysAssocKey );
        					xfr.xfrRef( key );
        					xfr.xfrRef( fn );
        					xfr.xfrRef( pc[1] );	//	Reference to the current method table entry.
        					pc[1] = xfr.makeRef();
        					vm->gcLiftVeto();
        				}
        				
        				//	Now we chain into the fragment we have recovered, utilising the
        				//	fact that this is a lightweight call.
        				
        				Ref * fn_K = RefToPtr4( fn );
        				
        				//	Leave VMLINK & VMLINKFUNC alone.
        				//	The lite function has not stashed them into the callstack.
        				//	As a consequence we can chain directly without meddling with
        				//	them.
        				
        				VMPCFUNC = fn_K;
        				RETURN( fn_K + 1 );
        			} else {
        				dispatch_table = entry_K[ ASSOC_NEXT_OFFSET ];
        			}
        		}	
        		/* Failed to find a matching method */
        	}
        }
        invoke_error();
        RETURN( pc );	// IDIOT COMPILER.
    }
    L_listiterate: {
        //	This instruction implements the fast iterator for lists.
        //	It may assume that there 2 items on the stack (L:List, _) on input.
        //	Since there were 2 inputs, it may therefore safely return 2 items
        //	without a stack check.
        
        Ref list = VMVP[-1];	//	Ignore VMVP[0], which is a dummy value.
        if ( IsPair( list ) ) {
        	VMVP[0] = RefToPtr4( list )[ PAIR_TAIL_OFFSET ];
        	VMVP[-1] = RefToPtr4( list )[ PAIR_HEAD_OFFSET ];
        } else {
        	VMVP[0] = sys_termin;	//	Signals exit.
        }
        
        
        VMPCFUNC = VMLINKFUNC;
        RETURN( VMLINK );
    }
    L_lt_si: {
        long s = ToLong( pc[1] );
        long i = ToLong( pc[2] );
        long d = ToLong( pc[3] );
        RETURN( ToLong( LOCAL( s ) ) < i ? pc + d + 3 : pc + 4 );
    }
    L_lt_ss: {
        long s = ToLong( pc[1] );
        long t = ToLong( pc[2] );
        long d = ToLong( pc[3] );
        RETURN( ToLong( LOCAL( s ) ) < ToLong( LOCAL( t ) ) ? pc + d + 3 : pc + 4 );
    }
    L_lte_si: {
        long s = ToLong( pc[1] );
        long i = ToLong( pc[2] );
        long d = ToLong( pc[3] );
        RETURN( ToLong( LOCAL( s ) ) <= i ? pc + d + 3 : pc + 4 );
    }
    L_lte_ss: {
        long s = ToLong( pc[1] );
        long t = ToLong( pc[2] );
        long d = ToLong( pc[3] );
        RETURN( ToLong( LOCAL( s ) ) <= ToLong( LOCAL( t ) ) ? pc + d + 3 : pc + 4 );
    }
    L_neq_si: {
        long s = ToLong( pc[1] );
        long i = ToLong( pc[2] );
        RETURN( ToLong( LOCAL( s ) ) == i ? pc + 4 : pc + ToLong( pc[3] ) + 3 );
    }
    L_neq_ss: {
        long s = ToLong( pc[1] );
        long t = ToLong( pc[2] );
        long d = ToLong( pc[3] );
        RETURN( ToLong( LOCAL( s ) ) != ToLong( LOCAL( t ) ) ? pc + d + 3 : pc + 4 );
    }
    L_not: {
        *VMVP = ( *VMVP == sys_false ? sys_true : sys_false );
        RETURN( pc + 1 );
    }
    L_pop_global: {
        Valof * id = (Valof *)( *( ++pc ) );
        id->valof = *( VMVP-- );
        RETURN( pc + 1 );
    }
    L_pop_local: {
        LOCAL( ToLong( *( ++pc ) ) ) = *( VMVP-- );
        RETURN( pc + 1 );
    }
    L_push_global: {
        Valof * id = (Valof *)( *( ++pc ) );
        *( ++VMVP ) = id->valof;
        RETURN( pc + 1 );
    }
    L_push_local: {
        *( ++VMVP ) = LOCAL( ToLong( *( ++pc ) ) );
        RETURN( pc + 1 );
    }
    L_push_local0: {
        *( ++VMVP ) = LOCAL(0);
        RETURN( pc + 1 );
    }
    L_push_local1: {
        *( ++VMVP ) = LOCAL(1);
        RETURN( pc + 1 );
    }
    L_pushq: {
        *( ++VMVP ) = *( ++pc );
        RETURN( pc + 1 );
    }
    L_reset: {
        FREEZE;
        throw NormalExit();
    }
    L_return: {
        Ref *linkptr;
        VMPCFUNC = ToRefRef( VMSP[ SP_FUNC ] );
        linkptr = ToRefRef( VMSP[ SP_LINK ] );				//	recover return address
        VMSP = ToRefRef( VMSP[ SP_PREV_SP ] );				//	restore stack pointer
        #ifdef DBG_SPECIAL
        	printf( "Recover link = %x\n", ToUInt( link ) );
        	printf( "Stack pointer recovered as %x\n", ToUInt( VMSP ) );
        #endif
        RETURN( linkptr );
    }
    L_set: {
        VMCOUNT = VMVP - (Ref *)LOCAL( ToLong( pc[ 1 ] ) );
        RETURN( pc + 2 );
    }
    L_set_call_global: {
        Ref r = ((Valof *)( pc[ 2 ] )) -> valof;
        VMCOUNT = ToLong( pc[ 1 ] );
        {    
            Ref *ptr;
            if ( !IsObj( r ) ) call_error( r );
            ptr = RefToPtr4( r );
            if ( !IsFunctionKey( *ptr ) ) call_error( r );
            VMLINK = pc + 3;
            VMLINKFUNC = VMPCFUNC;
        	VMPCFUNC = ptr;
            RETURN( ptr + 1 );
        }
    }
    L_set_calls: {
        Ref r = *( VMVP-- );
        VMCOUNT = ToLong( pc[ 1 ] );
        {    
            Ref *ptr;
            if ( !IsObj( r ) ) call_error( r );
            ptr = RefToPtr4( r );
            if ( !IsFunctionKey( *ptr ) ) call_error( r );
            VMLINK = pc + 2;
            VMLINKFUNC = VMPCFUNC;
            VMPCFUNC = ptr;
            RETURN( ptr + 1 );
        }
    }
    L_set_syscall: {
        VMCOUNT = ToLong( pc[ 1 ] );
        SysCall * sys = ToSysCall( pc[ 2 ] );
        FREEZE;
        pc = (*sys)( pc + 3, vm );
        MELT;
        RETURN( pc );
    }
    L_start_mark: {
        long n = ToLong( *( ++pc ) );
        #ifdef DBG_SPECIAL
        fprintf( stderr, "Storing %u in %d\n", ToULong( ToRef( VMVP ) ), n );
        #endif
        LOCAL(n) = ToRef( VMVP );
        RETURN( pc + 1 );
    }
    L_stringiterate: {
        //	This instruction implements the fast iterator for vectors.
        //	It may assume that there 2 items on the stack (i:Small, v:Vector) on input.
        //	Since there were 2 inputs, it may therefore safely return 2 items
        //	without a stack check.
        
        Ref * string = RefToPtr4( VMVP[0] );
        Ref len_as_small = string[ STRING_LENGTH_OFFSET ];
        Ref index = VMVP[-1];
        
        //	Is is safe to compare smalls this way.
        if ( index < len_as_small ) {
        	VMVP[-1] = CharToCharacter( reinterpret_cast< unsigned char * >( string + 1 )[ SmallToLong( index ) ] );
        	VMVP[0] = ToRef( (long)index + (long)LongToSmall( 1 ) );			//	It is safe to add smalls like this too.
        } else {
        	VMVP[0]	= sys_termin;
        }
        
        VMPCFUNC = VMLINKFUNC;
        RETURN( VMLINK );
    }
    L_syscall: {
        SysCall * sys = ToSysCall( *++pc );
        FREEZE;
        pc = (*sys)( ++pc, vm );
        MELT;
        RETURN( pc );
    }
    L_syscall_arg: {
        SysCall * sys = ToSysCall( pc[ 1 ] );
        FREEZE;
        //	Skip the data arg. The system call picks it up via pc[-1]. Note that
        //	it is NOT garbage collected. That means it cannot be an object.
        pc = (*sys)( pc + 3, vm );
        MELT;
        RETURN( pc );
    }
    L_syscall_dat: {
        SysCall * sys = ToSysCall( pc[ 1 ] );
        FREEZE;
        //	Skip the data arg. The system call picks it up via pc[-1]. Note that
        //	it is NOT garbage collected. That means it cannot be an object.
        pc = (*sys)( pc + 3, vm );
        MELT;
        RETURN( pc );
    }
    L_syscall_argdat: {
        SysCall * sys = ToSysCall( pc[ 1 ] );
        FREEZE;
        //	Skip the data arg. The system call picks it up via pc[-1]. Note that
        //	it is NOT garbage collected. That means it cannot be an object.
        pc = (*sys)( pc + 4, vm );
        MELT;
        RETURN( pc );
    }
    L_sysreturn: {
        VMPCFUNC = VMLINKFUNC;
        RETURN( VMLINK );
    }
    L_vectoriterate: {
        //	This instruction implements the fast iterator for vectors.
        //	It may assume that there 2 items on the stack (i:Small, v:Vector) on input.
        //	Since there were 2 inputs, it may therefore safely return 2 items
        //	without a stack check.
        
        Ref * vector = RefToPtr4( VMVP[0] );
        Ref len_as_small = vector[ VECTOR_LENGTH_OFFSET ];
        Ref index = VMVP[-1];
        
        //	Is is safe to compare smalls this way.
        if ( index > len_as_small ) {
        	VMVP[0]	= sys_termin;
        } else {
        	VMVP[-1] = vector[ SmallToLong( index ) ];
        	VMVP[0] = ToRef( (long)index + (long)LongToSmall( 1 ) );			//	It is safe to add smalls like this too.
        }
        
        VMPCFUNC = VMLINKFUNC;
        RETURN( VMLINK );
    }
    Initialize: {
        InstructionSet & ins = vm->instruction_set;
        ins.spc_add = &&L_add;
        ins.spc_decr = &&L_decr;
        ins.spc_div = &&L_div;
        ins.spc_eq = &&L_eq;
        ins.spc_neq = &&L_neq;
        ins.spc_gt = &&L_gt;
        ins.spc_gte = &&L_gte;
        ins.spc_incr = &&L_incr;
        ins.spc_incr_by = &&L_incr_by;
        ins.spc_lt = &&L_lt;
        ins.spc_lte = &&L_lte;
        ins.spc_mul = &&L_mul;
        ins.spc_sub = &&L_sub;
        ins.spc_calls = &&L_calls;
        ins.spc_chainlite = &&L_chainlite;
        ins.spc_check_count = &&L_check_count;
        ins.spc_check_mark0 = &&L_check_mark0;
        ins.spc_check_mark1 = &&L_check_mark1;
        ins.spc_end_mark = &&L_end_mark;
        ins.spc_end1_calls = &&L_end1_calls;
        ins.spc_end_call_global = &&L_end_call_global;
        ins.spc_enter = &&L_enter;
        ins.spc_enter0 = &&L_enter0;
        ins.spc_enter1 = &&L_enter1;
        ins.spc_eq_si = &&L_eq_si;
        ins.spc_eq_ss = &&L_eq_ss;
        ins.spc_field = &&L_field;
        ins.spc_getiterator = &&L_getiterator;
        ins.spc_goto = &&L_goto;
        ins.spc_gt_si = &&L_gt_si;
        ins.spc_gt_ss = &&L_gt_ss;
        ins.spc_gte_si = &&L_gte_si;
        ins.spc_gte_ss = &&L_gte_ss;
        ins.spc_halt = &&L_halt;
        ins.spc_ifnot = &&L_ifnot;
        ins.spc_ifso = &&L_ifso;
        ins.spc_invoke = &&L_invoke;
        ins.spc_listiterate = &&L_listiterate;
        ins.spc_lt_si = &&L_lt_si;
        ins.spc_lt_ss = &&L_lt_ss;
        ins.spc_lte_si = &&L_lte_si;
        ins.spc_lte_ss = &&L_lte_ss;
        ins.spc_neq_si = &&L_neq_si;
        ins.spc_neq_ss = &&L_neq_ss;
        ins.spc_not = &&L_not;
        ins.spc_pop_global = &&L_pop_global;
        ins.spc_pop_local = &&L_pop_local;
        ins.spc_push_global = &&L_push_global;
        ins.spc_push_local = &&L_push_local;
        ins.spc_push_local0 = &&L_push_local0;
        ins.spc_push_local1 = &&L_push_local1;
        ins.spc_pushq = &&L_pushq;
        ins.spc_reset = &&L_reset;
        ins.spc_return = &&L_return;
        ins.spc_set = &&L_set;
        ins.spc_set_call_global = &&L_set_call_global;
        ins.spc_set_calls = &&L_set_calls;
        ins.spc_set_syscall = &&L_set_syscall;
        ins.spc_start_mark = &&L_start_mark;
        ins.spc_stringiterate = &&L_stringiterate;
        ins.spc_syscall = &&L_syscall;
        ins.spc_syscall_arg = &&L_syscall_arg;
        ins.spc_syscall_dat = &&L_syscall_dat;
        ins.spc_syscall_argdat = &&L_syscall_argdat;
        ins.spc_sysreturn = &&L_sysreturn;
        ins.spc_vectoriterate = &&L_vectoriterate;
        return;
    }
}
