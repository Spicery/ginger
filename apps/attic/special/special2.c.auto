static Ref * spcfn__add( void ) {
    int y = ToInt( *( VMVP-- ) );
    int x = ToInt( *( VMVP ) );
    int sum = x + y;
    if ( x < 0 ? sum > y : sum < y ) {
        reset( "overflow detected %d + %d", x, y );
    }
    *VMVP = ToRef( sum );
    RETURN( pc + 1 );
    /*
    int y = ToInt( *( VMVP-- ) );
    *VMVP = ToRef( ToInt( *( VMVP ) ) + y );
    RETURN( pc + 1 );
    */
}

Special spc__add = spcfn__add;

static Ref * spcfn__decr( void ) {
    int x = ToInt( *( VMVP ) );
    int sum = x - ToInt( IntToSmall( 1 ) );
    if ( sum > x ) {
        reset( "integer overflow detected %d - 1", x );
    }
    *( VMVP ) = ToRef( sum );
    RETURN( pc + 1 );
    
    /*
    *( VMVP ) = ToRef( ToInt( *( VMVP ) ) - ToInt( IntToSmall( 1 ) ) );
    RETURN( pc + 1 );
    */
}

Special spc__decr = spcfn__decr;

static Ref * spcfn__div( void ) {
    int b = ToInt( *( VMVP-- ) );
    *( VMVP ) = ToRef( ToInt( *( VMVP ) ) / b );
    RETURN( pc + 1 );
}

Special spc__div = spcfn__div;

static Ref * spcfn__eq( void ) {
    Ref r = *( VMVP-- );
    *( VMVP ) = *( VMVP ) == r ? sys_true : sys_false;
    RETURN( pc + 1 );
}

Special spc__eq = spcfn__eq;

static Ref * spcfn__gt( void ) {
    int b = ToInt( *( VMVP-- ) );
    *( VMVP ) = ToInt( *( VMVP ) ) > b ? sys_true : sys_false;
    RETURN( pc + 1 );
}

Special spc__gt = spcfn__gt;

static Ref * spcfn__gte( void ) {
    int b = ToInt( *( VMVP-- ) );
    *( VMVP ) = ToInt( *( VMVP ) ) >= b ? sys_true : sys_false;
    RETURN( pc + 1 );
}

Special spc__gte = spcfn__gte;

static Ref * spcfn__incr( void ) {
    int x = ToInt( *( VMVP ) );
    int sum = x + ToInt( IntToSmall( 1 ) );
    if ( sum < x ) {
        reset( "integer overflow detected %d + 1", x );
    }
    *( VMVP ) = ToRef( sum );
    RETURN( pc + 1 );
    /*
    *( VMVP ) = ToRef( ToInt( *( VMVP ) ) + ToInt( IntToSmall( 1 ) ) );
    RETURN( pc + 1 );
    */
}

Special spc__incr = spcfn__incr;

static Ref * spcfn__incr_by( void ) {
    int x = ToInt( *( VMVP ) );
    int y = ToInt( pc[ 1 ] );
    int sum = x + y;
    if ( x < 0 ? sum > y : sum < y ) {
        reset( "overflow detected %d + %d", x, y );
    }
    *VMVP = ToRef( sum );
    RETURN( pc + 2 );
    /*
    int n = ToInt( pc[ 1 ] );
    *( VMVP ) = ToRef( ToInt( *( VMVP ) ) + n );
    RETURN( pc + 2 );
    */
}

Special spc__incr_by = spcfn__incr_by;

static Ref * spcfn__lt( void ) {
    int b = ToInt( *( VMVP-- ) );
    *( VMVP ) = ToInt( *( VMVP ) ) < b ? sys_true : sys_false;
    RETURN( pc + 1 );
}

Special spc__lt = spcfn__lt;

static Ref * spcfn__lte( void ) {
    int b = ToInt( *( VMVP-- ) );
    *( VMVP ) = ToInt( *( VMVP ) ) <= b ? sys_true : sys_false;
    RETURN( pc + 1 );
}

Special spc__lte = spcfn__lte;

static Ref * spcfn__mul( void ) {
    //  This needs to be given overflow detection!
    int b = ToInt( *( VMVP-- ) );
    *( VMVP ) = ToRef( ToInt( *( VMVP ) ) * ( b >> TAG ) );
    RETURN( pc + 1 );
}

Special spc__mul = spcfn__mul;

static Ref * spcfn__print( void ) {
    Ref r = *VMVP--;
    sys_print( r );
    RETURN( pc + 1 );
}

Special spc__print = spcfn__print;

static Ref * spcfn__putchar( void ) {
    putchar( ( ( unt )( *VMVP-- ) ) >> 8 );
    RETURN( pc + 1 );
}

Special spc__putchar = spcfn__putchar;

static Ref * spcfn__sub( void ) {
    //  This needs to be given overflow detection!
    int b = ToInt( *( VMVP-- ) );
    *( VMVP ) = ToRef( ToInt( *( VMVP ) ) - b );
    RETURN( pc + 1 );
}

Special spc__sub = spcfn__sub;

static Ref * spcfn_calls( void ) {
    Ref r = *( VMVP-- );
    {    
        Ref *ptr;
        if ( !IsPtr4( r ) ) call_error( r );
        ptr = RefToPtr4( r );
        if ( !IsFnKey( *ptr ) ) call_error( r );
        VMLINK = pc + 1;
        RETURN( ptr + 1 );
    }
}

Special spc_calls = spcfn_calls;

static Ref * spcfn_check0( void ) {
    int n = ToInt( *( ++pc ) );
    #ifdef DBG_SPECIAL
    fprintf(
    	stderr,
    	"Difference between %u and %u (held in %d)\n",
    	ToUInt( VMVP ),
    	ToUInt( VMSP[n] ),
    	n
    );
    #endif
    if ( VMVP == VMSP[n] ) RETURN( pc + 1 );
    reset( "Wrong number of results (needed 0 but got %u)", VMVP - ToRefRef( VMSP[n] ) );
    RETURN( NULL );	// stupid compiler
}

Special spc_check0 = spcfn_check0;

static Ref * spcfn_check1( void ) {
    int n = ToInt( *( ++pc ) );
    unsigned int d;
    #ifdef DBG_SPECIAL
    fprintf( stderr, "Recovering %u from %d\n", ToUInt( VMSP[n] ), n );
    fprintf( stderr, "Comparing with %u\n",  ToUInt( VMVP ) );
    fprintf( stderr, "Length of value stack = %d\n", ( VMVP - VMVP_base ) );
    #endif
    d = VMVP - ToRefRef( VMSP[n] );
    if ( d == 1 ) RETURN( pc + 1 );
    reset( "Wrong number of results (needed 1 but got %u)", d );
    RETURN( NULL );	// stupid compiler
}

Special spc_check1 = spcfn_check1;

static Ref * spcfn_end( void ) {
    Ref r;
    int n = ToInt( *( ++pc ) );
    #ifdef DBG_SPECIAL
    fprintf( stderr, "Recovering %u from %d\n", ToUInt( VMSP[n] ), n );
    fprintf( stderr, "Comparing with %u\n",  ToUInt( VMVP ) );
    fprintf( stderr, "Length of value stack = %d\n", ( VMVP - VMVP_base ) );
    #endif
    r = ToRef( ToUInt( VMVP ) - ToUInt( VMSP[n] ) );
    *( ++VMVP ) = r;
    RETURN( pc + 1 );
}

Special spc_end = spcfn_end;

static Ref * spcfn_end1_calls( void ) {
    Ref r = *( VMVP-- );
    int var = ToInt( pc[ 1 ] );
    VMCOUNT = ( VMVP - ( Ref * )( VMSP[ var ] ) ) - 1;
    {    
        Ref *ptr;
        if ( !IsPtr4( r ) ) call_error( r );
        ptr = RefToPtr4( r );
        if ( !IsFnKey( *ptr ) ) call_error( r );
        VMLINK = pc + 2;
        RETURN( ptr + 1 );
    }
}

Special spc_end1_calls = spcfn_end1_calls;

static Ref * spcfn_end_call_global( void ) {
    int var = ToInt( pc[ 1 ] );
    Ref r = ((Ident)( pc[ 2 ] )) -> valof;
    VMCOUNT = VMVP - ( Ref * )( VMSP[ var ] );
    {    
        Ref *ptr;
        if ( !IsPtr4( r ) ) call_error( r );
        ptr = RefToPtr4( r );
        if ( !IsFnKey( *ptr ) ) call_error( r );
        VMLINK = pc + 3;
        RETURN( ptr + 1 );
    }
}

Special spc_end_call_global = spcfn_end_call_global;

static Ref * spcfn_enter( void ) {
    int A = ToInt( pc[ -2 ] );
    Ref *prev = VMSP;
    VMSP += ToInt( VMSP[ -1 ] );
    VMSP[ 0 ] = VMLINK;
    VMSP[ 1 ] = prev;
    VMSP[ 2 ] = ToRef( pc[ -3 ] );
    VMSP += 3;
    if ( A != VMCOUNT ) enter_error( VMCOUNT, A );
    {    int i;
        for ( i = 0; i < A; i++ ) {
            VMSP[ i ] = *( VMVP-- );
        }
    }
    RETURN( pc + 1 );
}

Special spc_enter = spcfn_enter;

static Ref * spcfn_enter0( void ) {
    Ref *prev = VMSP;
    VMSP += ToInt( VMSP[ -1 ] );
    VMSP[ 0 ] = VMLINK;
    VMSP[ 1 ] = prev;
    VMSP[ 2 ] = ToRef( pc[ -3 ] );
    VMSP += 3;
    if ( VMCOUNT != 0 ) {
        enter_error( VMCOUNT, 0 );
    }
    RETURN( pc + 1 );
}

Special spc_enter0 = spcfn_enter0;

static Ref * spcfn_enter1( void ) {
    Ref *prev = VMSP;
    VMSP += ToInt( VMSP[ -1 ] );
    VMSP[ 0 ] = VMLINK;
    VMSP[ 1 ] = prev;
    VMSP[ 2 ] = ToRef( pc[ -3 ] );
    VMSP += 3;
    if ( VMCOUNT != 1 ) {
        enter_error( VMCOUNT, 1 );
    }
    VMSP[ 0 ] = *( VMVP-- );
    RETURN( pc + 1 );
}

Special spc_enter1 = spcfn_enter1;

static Ref * spcfn_eq_si( void ) {
    int s = ToInt( pc[1] );
    int i = ToInt( pc[2] );
    int d = ToInt( pc[3] );
    RETURN( ToInt( VMSP[ s ] ) == i ? pc + d + 3 : pc + 4 );
}

Special spc_eq_si = spcfn_eq_si;

static Ref * spcfn_eq_ss( void ) {
    int s = ToInt( pc[1] );
    int t = ToInt( pc[2] );
    int d = ToInt( pc[3] );
    RETURN( ToInt( VMSP[ s ] ) == ToInt( VMSP[ t ] ) ? pc + d + 3 : pc + 4 );
}

Special spc_eq_ss = spcfn_eq_ss;

static Ref * spcfn_goto( void ) {
    int n = ToInt( *( ++pc ) );
    RETURN( pc + n );
}

Special spc_goto = spcfn_goto;

static Ref * spcfn_gt_si( void ) {
    int s = ToInt( pc[1] );
    int i = ToInt( pc[2] );
    RETURN( ToInt( VMSP[ s ] ) > i ? pc + ToInt( pc[3] ) + 3 : pc + 4 );
}

Special spc_gt_si = spcfn_gt_si;

static Ref * spcfn_gt_ss( void ) {
    int s = ToInt( pc[1] );
    int t = ToInt( pc[2] );
    int d = ToInt( pc[3] );
    RETURN( ToInt( VMSP[ s ] ) > ToInt( VMSP[ t ] ) ? pc + d + 3 : pc + 4 );
}

Special spc_gt_ss = spcfn_gt_ss;

static Ref * spcfn_gte_si( void ) {
    int s = ToInt( pc[1] );
    int i = ToInt( pc[2] );
    int d = ToInt( pc[3] );
    RETURN( ToInt( VMSP[ s ] ) >= i ? pc + d + 3: pc + 4 );
}

Special spc_gte_si = spcfn_gte_si;

static Ref * spcfn_gte_ss( void ) {
    int s = ToInt( pc[1] );
    int t = ToInt( pc[2] );
    int d = ToInt( pc[3] );
    RETURN( ToInt( VMSP[ s ] ) >= ToInt( VMSP[ t ] ) ? pc + d + 3 : pc + 4 );
}

Special spc_gte_ss = spcfn_gte_ss;

static Ref * spcfn_halt( void ) {
    #ifdef DBG_SPECIAL	
    printf( "\nhalt\n" );
    #endif
    exit( EXIT_SUCCESS );
}

Special spc_halt = spcfn_halt;

static Ref * spcfn_ifnot( void ) {
    #ifdef DBG_SPECIAL
    fprintf( stderr, "IFNOT finds %x on the stack (cf. %x & %x)\n", (unt)(*( VMVP )), (unt)(sys_false), (unt)(sys_true) );
    #endif
    RETURN(
    	*( VMVP-- ) == sys_false ?
    	pc + ToInt( pc[ 1 ] ) + 1:
    	pc + 2
    );
}

Special spc_ifnot = spcfn_ifnot;

static Ref * spcfn_ifso( void ) {
    RETURN(
    	*( VMVP-- ) == sys_false ?
    	pc + 2 :
    	pc + ToInt( pc[ 1 ] ) + 1
    );
}

Special spc_ifso = spcfn_ifso;

static Ref * spcfn_lt_si( void ) {
    int s = ToInt( pc[1] );
    int i = ToInt( pc[2] );
    int d = ToInt( pc[3] );
    RETURN( ToInt( VMSP[ s ] ) < i ? pc + d + 3 : pc + 4 );
}

Special spc_lt_si = spcfn_lt_si;

static Ref * spcfn_lt_ss( void ) {
    int s = ToInt( pc[1] );
    int t = ToInt( pc[2] );
    int d = ToInt( pc[3] );
    RETURN( ToInt( VMSP[ s ] ) < ToInt( VMSP[ t ] ) ? pc + d + 3 : pc + 4 );
}

Special spc_lt_ss = spcfn_lt_ss;

static Ref * spcfn_lte_si( void ) {
    int s = ToInt( pc[1] );
    int i = ToInt( pc[2] );
    int d = ToInt( pc[3] );
    RETURN( ToInt( VMSP[ s ] ) <= i ? pc + d + 3 : pc + 4 );
}

Special spc_lte_si = spcfn_lte_si;

static Ref * spcfn_lte_ss( void ) {
    int s = ToInt( pc[1] );
    int t = ToInt( pc[2] );
    int d = ToInt( pc[3] );
    RETURN( ToInt( VMSP[ s ] ) <= ToInt( VMSP[ t ] ) ? pc + d + 3 : pc + 4 );
}

Special spc_lte_ss = spcfn_lte_ss;

static Ref * spcfn_neq_si( void ) {
    int s = ToInt( pc[1] );
    int i = ToInt( pc[2] );
    RETURN( ToInt( VMSP[ s ] ) == i ? pc + 4 : pc + ToInt( pc[3] ) + 3 );
}

Special spc_neq_si = spcfn_neq_si;

static Ref * spcfn_neq_ss( void ) {
    int s = ToInt( pc[1] );
    int t = ToInt( pc[2] );
    int d = ToInt( pc[3] );
    RETURN( ToInt( VMSP[ s ] ) != ToInt( VMSP[ t ] ) ? pc + d + 3 : pc + 4 );
}

Special spc_neq_ss = spcfn_neq_ss;

static Ref * spcfn_not( void ) {
    *VMVP = ( *VMVP == sys_false ? sys_true : sys_false );
    RETURN( pc + 1 );
}

Special spc_not = spcfn_not;

static Ref * spcfn_pop_global( void ) {
    Ident id = (Ident)( *( ++pc ) );
    id->valof = *( VMVP-- );
    RETURN( pc + 1 );
}

Special spc_pop_global = spcfn_pop_global;

static Ref * spcfn_pop_local( void ) {
    VMSP[ ToInt( *( ++pc ) ) ] = *( VMVP-- );
    RETURN( pc + 1 );
}

Special spc_pop_local = spcfn_pop_local;

static Ref * spcfn_push_global( void ) {
    Ident id = (Ident)( *( ++pc ) );
    *( ++VMVP ) = id->valof;
    RETURN( pc + 1 );
}

Special spc_push_global = spcfn_push_global;

static Ref * spcfn_push_local( void ) {
    *( ++VMVP ) = VMSP[ ToInt( *( ++pc ) ) ];
    RETURN( pc + 1 );
}

Special spc_push_local = spcfn_push_local;

static Ref * spcfn_push_local0( void ) {
    *( ++VMVP ) = VMSP[ 0 ];
    RETURN( pc + 1 );
}

Special spc_push_local0 = spcfn_push_local0;

static Ref * spcfn_push_local1( void ) {
    *( ++VMVP ) = VMSP[ 1 ];
    RETURN( pc + 1 );
}

Special spc_push_local1 = spcfn_push_local1;

static Ref * spcfn_pushq( void ) {
    *( ++VMVP ) = *( ++pc );
    RETURN( pc + 1 );
}

Special spc_pushq = spcfn_pushq;

static Ref * spcfn_reset( void ) {
    FREEZE;
    longjmp( mishap_jump_buffer, 2 );
}

Special spc_reset = spcfn_reset;

static Ref * spcfn_return( void ) {
    Ref *link;
    link = (Ref *)VMSP[ -3 ];	//	recover return address
    VMSP = (Ref *)VMSP[ -2 ];				//	restore stack pointer
    #ifdef DBG_SPECIAL
    	printf( "Recover link = %x\n", ToUInt( link ) );
    	printf( "Stack pointer recovered as %x\n", ToUInt( VMSP ) );
    #endif
    RETURN( link );
}

Special spc_return = spcfn_return;

static Ref * spcfn_set( void ) {
    VMCOUNT = VMVP - (Ref *)VMSP[ ToInt( pc[ 1 ] ) ];
    RETURN( pc + 2 );
}

Special spc_set = spcfn_set;

static Ref * spcfn_set_call_global( void ) {
    Ref r = ((Ident)( pc[ 2 ] )) -> valof;
    VMCOUNT = ToInt( pc[ 1 ] );
    {    
        Ref *ptr;
        if ( !IsPtr4( r ) ) call_error( r );
        ptr = RefToPtr4( r );
        if ( !IsFnKey( *ptr ) ) call_error( r );
        VMLINK = pc + 3;
        RETURN( ptr + 1 );
    }
}

Special spc_set_call_global = spcfn_set_call_global;

static Ref * spcfn_set_calls( void ) {
    Ref r = *( VMVP-- );
    VMCOUNT = ToInt( pc[ 1 ] );
    {    
        Ref *ptr;
        if ( !IsPtr4( r ) ) call_error( r );
        ptr = RefToPtr4( r );
        if ( !IsFnKey( *ptr ) ) call_error( r );
        VMLINK = pc + 2;
        RETURN( ptr + 1 );
    }
}

Special spc_set_calls = spcfn_set_calls;

static Ref * spcfn_start( void ) {
    int n = ToInt( *( ++pc ) );
    #ifdef DBG_SPECIAL
    fprintf( stderr, "Storing %u in %d\n", ToUInt( ToRef( VMVP ) ), n );
    #endif
    VMSP[n] = ToRef( VMVP );
    RETURN( pc + 1 );
}

Special spc_start = spcfn_start;

