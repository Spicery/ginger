void Machine3::core( bool init_mode, Ref *pc ) {
    Ref *VMSP, *VMVP, *VMLINK;
    if ( init_mode ) goto Initialize;
    MELT;
    goto **pc;
    L__add: {
        Ref ry = *( VMVP-- );
        Ref rx = *( VMVP );
        if ( IsSmall( rx ) && IsSmall( ry ) ) {
        	long y = (long)ry;
        	long x = (long)rx;
        	long sum = x + y;
        	if ( x < 0 ? sum <= y : sum >= y ) {
        		*VMVP = ToRef( sum );
        		RETURN( pc + 1 );
        	} else {
            	throw Mishap( "Overflow detected in +" );
        	}
        } else {
        	throw Mishap( "Small integers only" );
        } 
    }
    L__decr: {
        Ref rx = *VMVP;
        if ( IsSmall( rx ) ) {
        	long x = (long)rx;
        	long sum = x - (long)LongToSmall( 1 );
        	if ( sum > x ) {
        		throw Mishap( "integer overflow detected in x - 1" ).culprit( "x", "" + x );
        	}
        	*( VMVP ) = ToRef( sum );
        	RETURN( pc + 1 );
        } else {
        	throw Mishap( "Small integer needed" );
        }
        
        //*( VMVP ) = ToRef( ToLong( *( VMVP ) ) - ToLong( IntToSmall( 1 ) ) );
        //RETURN( pc + 1 );
    }
    L__div: {
        long b = ToLong( *( VMVP-- ) );
        *( VMVP ) = ToRef( ToLong( *( VMVP ) ) / b );
        RETURN( pc + 1 );
    }
    L__eq: {
        Ref r = *( VMVP-- );
        *( VMVP ) = *( VMVP ) == r ? sys_true : sys_false;
        RETURN( pc + 1 );
    }
    L__neq: {
        Ref r = *( VMVP-- );
        *( VMVP ) = *( VMVP ) == r ? sys_false : sys_true;
        RETURN( pc + 1 );
    }
    L__gt: {
        long b = ToLong( *( VMVP-- ) );
        *( VMVP ) = ToLong( *( VMVP ) ) > b ? sys_true : sys_false;
        RETURN( pc + 1 );
    }
    L__gte: {
        long b = ToLong( *( VMVP-- ) );
        *( VMVP ) = ToLong( *( VMVP ) ) >= b ? sys_true : sys_false;
        RETURN( pc + 1 );
    }
    L__incr: {
        Ref rx = *VMVP;
        if ( IsSmall( rx ) ) {
        	long x = (long)rx;
        	long sum = x + (long)LongToSmall( 1 );
        	if ( sum > x ) {
        		*( VMVP ) = ToRef( sum );
        		RETURN( pc + 1 );
        	} else {
        		throw Mishap( "integer overflow detected in x + 1" );
        	}
        } else {
        	throw Mishap( "Small integer needed" );
        }
        
    }
    L__incr_by: {
        Ref ry = ToRef( pc[ 1 ] );
        Ref rx = *( VMVP );
        if ( IsSmall( rx ) && IsSmall( ry ) ) {
        	long y = (long)ry;
        	long x = (long)rx;
        	long sum = x + y;
        	if ( x < 0 ? sum <= y : sum >= y ) {
        		*VMVP = ToRef( sum );
        		RETURN( pc + 2 );
        	} else {
            	throw Mishap( "Overflow detected in +" );
        	}
        } else {
        	throw Mishap( "Small integers only" );
        } 
    }
    L__lt: {
        long b = ToLong( *( VMVP-- ) );
        *( VMVP ) = ToLong( *( VMVP ) ) < b ? sys_true : sys_false;
        RETURN( pc + 1 );
    }
    L__lte: {
        long b = ToLong( *( VMVP-- ) );
        *( VMVP ) = ToLong( *( VMVP ) ) <= b ? sys_true : sys_false;
        RETURN( pc + 1 );
    }
    L__mul: {
        //  This needs to be given overflow detection!
        long b = ToLong( *( VMVP-- ) );
        *( VMVP ) = ToRef( ToLong( *( VMVP ) ) * ( b >> TAG ) );
        RETURN( pc + 1 );
    }
    L__sub: {
        //  This needs to be given overflow detection!
        long b = ToLong( *( VMVP-- ) );
        *( VMVP ) = ToRef( ToLong( *( VMVP ) ) - b );
        RETURN( pc + 1 );
    }
    L_calls: {
        Ref r = *( VMVP-- );
        {    
            Ref *ptr;
            if ( !IsPtr4( r ) ) call_error( r );
            ptr = RefToPtr4( r );
            if ( !IsFunction( *ptr ) ) call_error( r );
            VMLINK = pc + 1;
            VMLINKFUNC = VMPCFUNC;
            VMPCFUNC = ptr;
            RETURN( ptr + 1 );
        }
    }
    L_check0: {
        long n = ToLong( *( ++pc ) );
        #ifdef DBG_SPECIAL
        fprintf(
        	stderr,
        	"Difference between %lu and %lu (held in %ld)\n",
        	ToULong( VMVP ),
        	ToULong( VMSP[n] ),
        	n
        );
        #endif
        if ( VMVP == VMSP[n] ) RETURN( pc + 1 );
        throw Mishap( "Wrong number of results (needed 0)" ).culprit( "#Results", "" + ( VMVP - ToRefRef( VMSP[n] ) ) );
        RETURN( NULL );	// stupid compiler
    }
    L_check1: {
        long n = ToLong( *( ++pc ) );
        unsigned long d;
        #ifdef DBG_SPECIAL
        fprintf( stderr, "Recovering %lu from %ld\n", ToULong( VMSP[n] ), n );
        fprintf( stderr, "Comparing with %u\n",  ToULong( VMVP ) );
        fprintf( stderr, "Length of value stack = %d\n", ( VMVP - VMVP_base ) );
        #endif
        d = VMVP - ToRefRef( VMSP[n] );
        if ( d == 1 ) RETURN( pc + 1 );
        throw Mishap( "Wrong number of results (needed 1)" ).culprit( "#results", "" + d );
        RETURN( NULL );	// stupid compiler
    }
    L_end: {
        Ref r;
        long n = ToLong( *( ++pc ) );
        #ifdef DBG_SPECIAL
        fprintf( stderr, "Recovering %u from %d\n", ToULong( VMSP[n] ), n );
        fprintf( stderr, "Comparing with %u\n",  ToULong( VMVP ) );
        fprintf( stderr, "Length of value stack = %d\n", ( VMVP - VMVP_base ) );
        #endif
        r = ToRef( ToULong( VMVP ) - ToULong( VMSP[n] ) );
        *( ++VMVP ) = r;
        RETURN( pc + 1 );
    }
    L_end1_calls: {
        Ref r = *( VMVP-- );
        long var = ToLong( pc[ 1 ] );
        VMCOUNT = ( VMVP - ( Ref * )( VMSP[ var ] ) ) - 1;
        {    
            Ref *ptr;
            if ( !IsPtr4( r ) ) call_error( r );
            ptr = RefToPtr4( r );
            if ( !IsFunction( *ptr ) ) call_error( r );
            VMLINK = pc + 2;
            VMLINKFUNC = VMPCFUNC;
            VMPCFUNC = ptr;
            RETURN( ptr + 1 );
        }
    }
    L_end_call_global: {
        long var = ToLong( pc[ 1 ] );
        Ref r = ((IdentClass *)( pc[ 2 ] )) -> valof;
        VMCOUNT = VMVP - ( Ref * )( VMSP[ var ] );
        {    
            Ref *ptr;
            if ( !IsPtr4( r ) ) call_error( r );
            ptr = RefToPtr4( r );
            if ( !IsFunction( *ptr ) ) call_error( r );
            VMLINK = pc + 3;
            VMLINKFUNC = VMPCFUNC;
        	VMPCFUNC = ptr;
            RETURN( ptr + 1 );
        }
    }
    L_enter: {
        long A = ToLong( pc[ -2 ] ); // field before the function key.
        Ref *prev = VMSP;
        VMSP += ToLong( VMSP[ -1 ] );
        VMSP[ 0 ] = VMLINKFUNC;
        VMSP[ 1 ] = VMLINK;
        VMSP[ 2 ] = prev;
        VMSP[ 3 ] = ToRef( pc[ -3 ] );
        VMSP += SP_OVERHEAD;
        if ( A != VMCOUNT ) {
            enter_error( VMCOUNT, A );
        }
        {
            while ( --A >= 0 ) {
                VMSP[ A ] = *( VMVP-- );
            }
        }
        RETURN( pc + 1 );
    }
    L_enter0: {
        Ref *prev = VMSP;
        VMSP += ToLong( VMSP[ -1 ] );
        VMSP[ 0 ] = VMLINKFUNC;
        VMSP[ 1 ] = VMLINK;
        VMSP[ 2 ] = prev;
        VMSP[ 3 ] = ToRef( pc[ -3 ] );
        VMSP += SP_OVERHEAD;
        if ( VMCOUNT != 0 ) {
            enter_error( VMCOUNT, 0 );
        }
        RETURN( pc + 1 );
    }
    L_enter1: {
        Ref *prev = VMSP;
        VMSP += ToLong( VMSP[ -1 ] );
        VMSP[ 0 ] = VMLINKFUNC;
        VMSP[ 1 ] = VMLINK;
        VMSP[ 2 ] = prev;
        VMSP[ 3 ] = ToRef( pc[ -3 ] );
        VMSP += SP_OVERHEAD;
        if ( VMCOUNT != 1 ) {
            enter_error( VMCOUNT, 1 );
        }
        VMSP[ 0 ] = *( VMVP-- );
        RETURN( pc + 1 );
    }
    L_eq_si: {
        long s = ToLong( pc[1] );
        long i = ToLong( pc[2] );
        long d = ToLong( pc[3] );
        RETURN( ToLong( VMSP[ s ] ) == i ? pc + d + 3 : pc + 4 );
    }
    L_eq_ss: {
        long s = ToLong( pc[1] );
        long t = ToLong( pc[2] );
        long d = ToLong( pc[3] );
        RETURN( ToLong( VMSP[ s ] ) == ToLong( VMSP[ t ] ) ? pc + d + 3 : pc + 4 );
    }
    L_goto: {
        long n = ToLong( *( ++pc ) );
        RETURN( pc + n );
    }
    L_gt_si: {
        long s = ToLong( pc[1] );
        long i = ToLong( pc[2] );
        RETURN( ToLong( VMSP[ s ] ) > i ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
    }
    L_gt_ss: {
        long s = ToLong( pc[1] );
        long t = ToLong( pc[2] );
        long d = ToLong( pc[3] );
        RETURN( ToLong( VMSP[ s ] ) > ToLong( VMSP[ t ] ) ? pc + d + 3 : pc + 4 );
    }
    L_gte_si: {
        long s = ToLong( pc[1] );
        long i = ToLong( pc[2] );
        long d = ToLong( pc[3] );
        RETURN( ToLong( VMSP[ s ] ) >= i ? pc + d + 3: pc + 4 );
    }
    L_gte_ss: {
        long s = ToLong( pc[1] );
        long t = ToLong( pc[2] );
        long d = ToLong( pc[3] );
        RETURN( ToLong( VMSP[ s ] ) >= ToLong( VMSP[ t ] ) ? pc + d + 3 : pc + 4 );
    }
    L_halt: {
        #ifdef DBG_SPECIAL	
        printf( "\nhalt\n" );
        #endif
        exit( EXIT_SUCCESS );
    }
    L_ifnot: {
        #ifdef DBG_SPECIAL
        fprintf( stderr, "IFNOT finds %x on the stack (cf. %x & %x)\n", (unt)(*( VMVP )), (unt)(sys_false), (unt)(sys_true) );
        #endif
        RETURN(
        	*( VMVP-- ) == sys_false ?
        	pc + ToLong( pc[ 1 ] ) + 1:
        	pc + 2
        );
    }
    L_ifso: {
        RETURN(
        	*( VMVP-- ) == sys_false ?
        	pc + 2 :
        	pc + ToLong( pc[ 1 ] ) + 1
        );
    }
    L_lt_si: {
        long s = ToLong( pc[1] );
        long i = ToLong( pc[2] );
        long d = ToLong( pc[3] );
        RETURN( ToLong( VMSP[ s ] ) < i ? pc + d + 3 : pc + 4 );
    }
    L_lt_ss: {
        long s = ToLong( pc[1] );
        long t = ToLong( pc[2] );
        long d = ToLong( pc[3] );
        RETURN( ToLong( VMSP[ s ] ) < ToLong( VMSP[ t ] ) ? pc + d + 3 : pc + 4 );
    }
    L_lte_si: {
        long s = ToLong( pc[1] );
        long i = ToLong( pc[2] );
        long d = ToLong( pc[3] );
        RETURN( ToLong( VMSP[ s ] ) <= i ? pc + d + 3 : pc + 4 );
    }
    L_lte_ss: {
        long s = ToLong( pc[1] );
        long t = ToLong( pc[2] );
        long d = ToLong( pc[3] );
        RETURN( ToLong( VMSP[ s ] ) <= ToLong( VMSP[ t ] ) ? pc + d + 3 : pc + 4 );
    }
    L_neq_si: {
        long s = ToLong( pc[1] );
        long i = ToLong( pc[2] );
        RETURN( ToLong( VMSP[ s ] ) == i ? pc + 4 : pc + ToLong( pc[3] ) + 3 );
    }
    L_neq_ss: {
        long s = ToLong( pc[1] );
        long t = ToLong( pc[2] );
        long d = ToLong( pc[3] );
        RETURN( ToLong( VMSP[ s ] ) != ToLong( VMSP[ t ] ) ? pc + d + 3 : pc + 4 );
    }
    L_not: {
        *VMVP = ( *VMVP == sys_false ? sys_true : sys_false );
        RETURN( pc + 1 );
    }
    L_pop_global: {
        IdentClass * id = (IdentClass *)( *( ++pc ) );
        id->valof = *( VMVP-- );
        RETURN( pc + 1 );
    }
    L_pop_local: {
        VMSP[ ToLong( *( ++pc ) ) ] = *( VMVP-- );
        RETURN( pc + 1 );
    }
    L_push_global: {
        IdentClass * id = (IdentClass *)( *( ++pc ) );
        *( ++VMVP ) = id->valof;
        RETURN( pc + 1 );
    }
    L_push_local: {
        *( ++VMVP ) = VMSP[ ToLong( *( ++pc ) ) ];
        RETURN( pc + 1 );
    }
    L_push_local0: {
        *( ++VMVP ) = VMSP[ 0 ];
        RETURN( pc + 1 );
    }
    L_push_local1: {
        *( ++VMVP ) = VMSP[ 1 ];
        RETURN( pc + 1 );
    }
    L_pushq: {
        *( ++VMVP ) = *( ++pc );
        RETURN( pc + 1 );
    }
    L_reset: {
        FREEZE;
        throw NormalExit();
    }
    L_return: {
        Ref *linkptr;
        VMPCFUNC = (Ref *)VMSP[ SP_FUNC ];
        linkptr = (Ref *)VMSP[ SP_LINK ];				//	recover return address
        VMSP = (Ref *)VMSP[ SP_PREV_SP ];				//	restore stack pointer
        #ifdef DBG_SPECIAL
        	printf( "Recover link = %x\n", ToUInt( link ) );
        	printf( "Stack pointer recovered as %x\n", ToUInt( VMSP ) );
        #endif
        RETURN( linkptr );
    }
    L_set: {
        VMCOUNT = VMVP - (Ref *)VMSP[ ToLong( pc[ 1 ] ) ];
        RETURN( pc + 2 );
    }
    L_set_call_global: {
        Ref r = ((IdentClass *)( pc[ 2 ] )) -> valof;
        VMCOUNT = ToLong( pc[ 1 ] );
        {    
            Ref *ptr;
            if ( !IsPtr4( r ) ) call_error( r );
            ptr = RefToPtr4( r );
            if ( !IsFunction( *ptr ) ) call_error( r );
            VMLINK = pc + 3;
            VMLINKFUNC = VMPCFUNC;
        	VMPCFUNC = ptr;
            RETURN( ptr + 1 );
        }
    }
    L_set_calls: {
        Ref r = *( VMVP-- );
        VMCOUNT = ToLong( pc[ 1 ] );
        {    
            Ref *ptr;
            if ( !IsPtr4( r ) ) call_error( r );
            ptr = RefToPtr4( r );
            if ( !IsFunction( *ptr ) ) call_error( r );
            VMLINK = pc + 2;
            VMLINKFUNC = VMPCFUNC;
            VMPCFUNC = ptr;
            RETURN( ptr + 1 );
        }
    }
    L_start: {
        long n = ToLong( *( ++pc ) );
        #ifdef DBG_SPECIAL
        fprintf( stderr, "Storing %u in %d\n", ToULong( ToRef( VMVP ) ), n );
        #endif
        VMSP[n] = ToRef( VMVP );
        RETURN( pc + 1 );
    }
    L_syscall: {
        SysCall * sys = ToSysCall( *++pc );
        FREEZE;
        pc = (*sys)( ++pc, vm );
        MELT;
        RETURN( pc );
    }
    Initialize: {
        InstructionSet & ins = vm->instruction_set;
        ins.spc__add = &&L__add;
        ins.spc__decr = &&L__decr;
        ins.spc__div = &&L__div;
        ins.spc__eq = &&L__eq;
        ins.spc__neq = &&L__neq;
        ins.spc__gt = &&L__gt;
        ins.spc__gte = &&L__gte;
        ins.spc__incr = &&L__incr;
        ins.spc__incr_by = &&L__incr_by;
        ins.spc__lt = &&L__lt;
        ins.spc__lte = &&L__lte;
        ins.spc__mul = &&L__mul;
        ins.spc__sub = &&L__sub;
        ins.spc_calls = &&L_calls;
        ins.spc_check0 = &&L_check0;
        ins.spc_check1 = &&L_check1;
        ins.spc_end = &&L_end;
        ins.spc_end1_calls = &&L_end1_calls;
        ins.spc_end_call_global = &&L_end_call_global;
        ins.spc_enter = &&L_enter;
        ins.spc_enter0 = &&L_enter0;
        ins.spc_enter1 = &&L_enter1;
        ins.spc_eq_si = &&L_eq_si;
        ins.spc_eq_ss = &&L_eq_ss;
        ins.spc_goto = &&L_goto;
        ins.spc_gt_si = &&L_gt_si;
        ins.spc_gt_ss = &&L_gt_ss;
        ins.spc_gte_si = &&L_gte_si;
        ins.spc_gte_ss = &&L_gte_ss;
        ins.spc_halt = &&L_halt;
        ins.spc_ifnot = &&L_ifnot;
        ins.spc_ifso = &&L_ifso;
        ins.spc_lt_si = &&L_lt_si;
        ins.spc_lt_ss = &&L_lt_ss;
        ins.spc_lte_si = &&L_lte_si;
        ins.spc_lte_ss = &&L_lte_ss;
        ins.spc_neq_si = &&L_neq_si;
        ins.spc_neq_ss = &&L_neq_ss;
        ins.spc_not = &&L_not;
        ins.spc_pop_global = &&L_pop_global;
        ins.spc_pop_local = &&L_pop_local;
        ins.spc_push_global = &&L_push_global;
        ins.spc_push_local = &&L_push_local;
        ins.spc_push_local0 = &&L_push_local0;
        ins.spc_push_local1 = &&L_push_local1;
        ins.spc_pushq = &&L_pushq;
        ins.spc_reset = &&L_reset;
        ins.spc_return = &&L_return;
        ins.spc_set = &&L_set;
        ins.spc_set_call_global = &&L_set_call_global;
        ins.spc_set_calls = &&L_set_calls;
        ins.spc_start = &&L_start;
        ins.spc_syscall = &&L_syscall;
        return;
    }
}
