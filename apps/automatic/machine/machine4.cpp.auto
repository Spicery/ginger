case vmc_add: {
    Ref ry = *( VMVP-- );
    Ref rx = *( VMVP );
    if ( IsSmall( rx ) && IsSmall( ry ) ) {
    	long y = (long)ry;
    	long x = (long)rx;
    	long sum = x + y;
    	if ( x < 0 ? sum <= y : sum >= y ) {
    		*VMVP = ToRef( sum );
    		RETURN( pc + 1 );
    	} else {
        	throw Mishap( "Overflow detected in +" );
    	}
    } else {
    	throw Mishap( "Small integers only" );
    } 
}; break;

case vmc_decr: {
    Ref rx = *VMVP;
    if ( IsSmall( rx ) ) {
    	long x = (long)rx;
    	long sum = x - (long)LongToSmall( 1 );
    	if ( sum > x ) {
    		throw Mishap( "integer overflow detected in x - 1" ).culprit( "x", "" + x );
    	}
    	*( VMVP ) = ToRef( sum );
    	RETURN( pc + 1 );
    } else {
    	throw Mishap( "Small integer needed" );
    }
    
    //*( VMVP ) = ToRef( ToLong( *( VMVP ) ) - ToLong( IntToSmall( 1 ) ) );
    //RETURN( pc + 1 );
}; break;

case vmc_div: {
    long b = ToLong( *( VMVP-- ) );
    *( VMVP ) = ToRef( ToLong( *( VMVP ) ) / b );
    RETURN( pc + 1 );
}; break;

case vmc_eq: {
    Ref r = *( VMVP-- );
    *( VMVP ) = *( VMVP ) == r ? SYS_TRUE : SYS_FALSE;
    RETURN( pc + 1 );
}; break;

case vmc_neq: {
    Ref r = *( VMVP-- );
    *( VMVP ) = *( VMVP ) == r ? SYS_FALSE : SYS_TRUE;
    RETURN( pc + 1 );
}; break;

case vmc_gt: {
    Ref b = *( VMVP-- );
    Ref a = *( VMVP );
    
    if ( not( IsSmall( a ) ) or not( IsSmall( b ) ) ) {
    	throw Mishap( "Small integers needed" );
    }
    
    *( VMVP ) = ToLong( a ) > ToLong( b ) ? SYS_TRUE : SYS_FALSE;
    RETURN( pc + 1 );
}; break;

case vmc_gte: {
    Ref b = *( VMVP-- );
    Ref a = *VMVP;
    
    if ( not( IsSmall( a ) ) or not( IsSmall( b ) ) ) {
    	throw Mishap( "Small integers needed" );
    }
    
    *( VMVP ) = ToLong( a ) >= ToLong( b ) ? SYS_TRUE : SYS_FALSE;
    RETURN( pc + 1 );
}; break;

case vmc_incr: {
    Ref rx = *VMVP;
    if ( IsSmall( rx ) ) {
    	long x = (long)rx;
    	long sum = x + (long)LongToSmall( 1 );
    	if ( sum > x ) {
    		*( VMVP ) = ToRef( sum );
    		RETURN( pc + 1 );
    	} else {
    		throw Mishap( "integer overflow detected in x + 1" );
    	}
    } else {
    	throw Mishap( "Small integer needed" );
    }
    
}; break;

case vmc_incr_by: {
    Ref ry = ToRef( pc[ 1 ] );
    Ref rx = *( VMVP );
    if ( IsSmall( rx ) && IsSmall( ry ) ) {
    	long y = (long)ry;
    	long x = (long)rx;
    	long sum = x + y;
    	if ( x < 0 ? sum <= y : sum >= y ) {
    		*VMVP = ToRef( sum );
    		RETURN( pc + 2 );
    	} else {
        	throw Mishap( "Overflow detected in +" );
    	}
    } else {
    	throw Mishap( "Small integers only" );
    } 
}; break;

case vmc_lt: {
    Ref b = *( VMVP-- );
    Ref a = *( VMVP );
    
    if ( not IsSmall( a ) or not IsSmall( b ) ) {
    	throw Mishap( "Small integers only" );
    }
    
    *( VMVP ) = ToLong( a ) < ToLong( b ) ? SYS_TRUE : SYS_FALSE;
    RETURN( pc + 1 );
}; break;

case vmc_lte: {
    Ref b = *( VMVP-- );
    Ref a = *( VMVP );
    
    if ( not( IsSmall( a ) ) or not( IsSmall( b ) ) ) {
    	throw Mishap( "Small integers needed" );
    }
    
    *( VMVP ) = ToLong( a ) <= ToLong( b ) ? SYS_TRUE : SYS_FALSE;
    RETURN( pc + 1 );
}; break;

case vmc_mul: {
    //  This needs to be given overflow detection!
    long b = ToLong( *( VMVP-- ) );
    *( VMVP ) = ToRef( ToLong( *( VMVP ) ) * ( b >> TAG ) );
    RETURN( pc + 1 );
}; break;

case vmc_sub: {
    //  This needs to be given overflow detection!
    long b = ToLong( *( VMVP-- ) );
    *( VMVP ) = ToRef( ToLong( *( VMVP ) ) - b );
    RETURN( pc + 1 );
}; break;

case vmc_calls: {
    Ref r = *( VMVP-- );
    {    
        Ref *ptr;
        if ( !IsObj( r ) ) call_error( r );
        ptr = RefToPtr4( r );
        if ( !IsFunctionKey( *ptr ) ) call_error( r );
        VMLINK = pc + 1;
        VMLINKFUNC = VMPCFUNC;
        VMPCFUNC = ptr;
        RETURN( ptr + 1 );
    }
}; break;

case vmc_chainlite: {
    Ref * fn_K = RefToPtr4( pc[ 1 ] );
    VMCOUNT += ToLong( pc[2] );
    
    //	Leave VMLINK & VMLINKFUNC alone.
    //	The lite function has not stashed them into the callstack.
    //	As a consequence we can chain directly without meddling with
    //	them.
    
    VMPCFUNC = fn_K;
    RETURN( fn_K + 1 );
}; break;

case vmc_check_count: {
    long n = ToLong( *( ++pc ) );
    #ifdef DBG_SPECIAL
    fprintf(
    	stderr,
    	"Difference between %lu and %lu (held in %ld)\n",
    	ToULong( VMVP ),
    	ToULong( LOCAL(n) ),
    	n
    );
    #endif
    if ( VMCOUNT == n ) RETURN( pc + 1 );
    throw Mishap( "Wrong number of results (needed 0)" ).culprit( "#Results", "" + ( VMVP - ToRefRef( LOCAL(n) ) ) );
    RETURN( NULL );	// stupid compiler
}; break;

case vmc_check_mark0: {
    long n = ToLong( *( ++pc ) );
    #ifdef DBG_SPECIAL
    fprintf(
    	stderr,
    	"Difference between %lu and %lu (held in %ld)\n",
    	ToULong( VMVP ),
    	ToULong( LOCAL(n) ),
    	n
    );
    #endif
    if ( VMVP == LOCAL(n) ) RETURN( pc + 1 );
    throw Mishap( "Wrong number of results (needed 0)" ).culprit( "#Results", "" + ( VMVP - ToRefRef( LOCAL(n) ) ) );
    RETURN( NULL );	// stupid compiler
}; break;

case vmc_check_mark1: {
    long n = ToLong( *( ++pc ) );
    unsigned long d;
    #ifdef DBG_SPECIAL
    fprintf( stderr, "Recovering %lu from %ld\n", ToULong( LOCAL(n) ), n );
    fprintf( stderr, "Comparing with %u\n",  ToULong( VMVP ) );
    fprintf( stderr, "Length of value stack = %d\n", ( VMVP - VMVP_base ) );
    #endif
    d = VMVP - ToRefRef( LOCAL(n) );
    if ( d == 1 ) RETURN( pc + 1 );
    throw Mishap( "Wrong number of results (needed 1)" ).culprit( "#results", "" + d );
    RETURN( NULL );	// stupid compiler
}; break;

case vmc_end_mark: {
    Ref r;
    long n = ToLong( *( ++pc ) );
    #ifdef DBG_SPECIAL
    fprintf( stderr, "Recovering %u from %d\n", ToULong( LOCAL(n) ), n );
    fprintf( stderr, "Comparing with %u\n",  ToULong( VMVP ) );
    fprintf( stderr, "Length of value stack = %d\n", ( VMVP - VMVP_base ) );
    #endif
    r = ToRef( ToULong( VMVP ) - ToULong( LOCAL(n) ) );
    *( ++VMVP ) = r;
    RETURN( pc + 1 );
}; break;

case vmc_end1_calls: {
    Ref r = *( VMVP-- );							//	Reduce stack by 1, safely.
    long var = ToLong( pc[ 1 ] );
    VMCOUNT = ( VMVP - ToRefRef( LOCAL( var ) ) );	//	Stack reduced by 1 already, don't redo.
    {    
        Ref *ptr;
        if ( !IsObj( r ) ) call_error( r );
        ptr = RefToPtr4( r );
        if ( !IsFunctionKey( *ptr ) ) call_error( r );
        VMLINK = pc + 2;
        VMLINKFUNC = VMPCFUNC;
        VMPCFUNC = ptr;
        RETURN( ptr + 1 );
    }
}; break;

case vmc_end_call_global: {
    long var = ToLong( pc[ 1 ] );
    Ref r = ((Valof *)( pc[ 2 ] )) -> valof;
    VMCOUNT = VMVP - ToRefRef( LOCAL( var ) );
    {    
        Ref *ptr;
        if ( !IsObj( r ) ) call_error( r );
        ptr = RefToPtr4( r );
        if ( !IsFunctionKey( *ptr ) ) call_error( r );
        VMLINK = pc + 3;
        VMLINKFUNC = VMPCFUNC;
    	VMPCFUNC = ptr;
        RETURN( ptr + 1 );
    }
}; break;

case vmc_enter: {
    //
    //	ENTER only works as the 1st instruction of a function.
    //	It uses -ve offsets to access the fields before the key.
    //
    long A = ToLong( pc[ -2 ] ); // field before the function key.
    Ref *prev = VMSP;
    VMSP -= SP_OVERHEAD + ToULong( pc[ -3 ] );
    VMSP[ SP_PREV_SP ] = prev;
    VMSP[ SP_LINK ] = VMLINK;
    VMSP[ SP_FUNC ] = VMLINKFUNC;
    if ( A != VMCOUNT ) {
        enter_error( VMCOUNT, A );
    }
    {
        while ( --A >= 0 ) {
            LOCAL( A ) = *( VMVP-- );
        }
    }
    RETURN( pc + 1 );
}; break;

case vmc_enter0: {
    //	ENTER0 only works as the 1st instruction of a function.
    Ref *prev = VMSP;
    VMSP -= SP_OVERHEAD + ToULong( pc[ -3 ] );
    VMSP[ SP_PREV_SP ] = prev;
    VMSP[ SP_LINK ] = VMLINK;
    VMSP[ SP_FUNC ] = VMLINKFUNC;
    if ( VMCOUNT != 0 ) {
        enter_error( VMCOUNT, 0 );
    }
    RETURN( pc + 1 );
}; break;

case vmc_enter1: {
    //	ENTER1 only works as the 1st instruction of a function.
    Ref *prev = VMSP;
    VMSP -= SP_OVERHEAD + ToULong( pc[ -3 ] );
    VMSP[ SP_PREV_SP ] = prev;
    VMSP[ SP_LINK ] = VMLINK;
    VMSP[ SP_FUNC ] = VMLINKFUNC;
    if ( VMCOUNT != 1 ) {
        enter_error( VMCOUNT, 1 );
    }
    LOCAL( 0 ) = *( VMVP-- );
    RETURN( pc + 1 );
}; break;

case vmc_eq_si: {
    long s = ToLong( pc[1] );
    long i = ToLong( pc[2] );
    long d = ToLong( pc[3] );
    RETURN( ToLong( LOCAL( s ) ) == i ? pc + d + 3 : pc + 4 );
}; break;

case vmc_eq_ss: {
    long s = ToLong( pc[1] );
    long t = ToLong( pc[2] );
    long d = ToLong( pc[3] );
    RETURN( ToLong( LOCAL( s ) ) == ToLong( LOCAL( t ) ) ? pc + d + 3 : pc + 4 );
}; break;

case vmc_erase: {
    {
    	VMVP--;					//	Decrement the value-stack pointer.
    	RETURN( pc + 1 );		//	Return the next instruction.
    }
}; break;

case vmc_field: {
    unsigned long N = ToULong( *++pc );
    VMVP[0] = RefToPtr4( VMVP[0] )[ N ];
    RETURN( pc + 1 );
}; break;

case vmc_getiterator: {
    FREEZE;
    pc = sysFastGetFastIterator( pc, vm );
    MELT;
    RETURN( pc + 1 );
}; break;

case vmc_goto: {
    long n = ToLong( *( ++pc ) );
    RETURN( pc + n );
}; break;

case vmc_gt_si: {
    long s = ToLong( pc[1] );
    Ref a = LOCAL( s );
    Ref b = pc[2];
    
    if ( not( IsSmall( a ) ) or not( IsSmall( b ) ) ) {
    	throw Mishap( "Small integers needed" );
    }
    
    RETURN( ToLong( a ) > ToLong( b ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
}; break;

case vmc_gt_ss: {
    long s = ToLong( pc[1] );
    long t = ToLong( pc[2] );
    Ref a = LOCAL( s );
    Ref b = LOCAL( t );
    
    if ( not( IsSmall( a ) ) or not( IsSmall( b ) ) ) {
    	throw Mishap( "Small integers needed" );
    }
    
    long d = ToLong( pc[3] );
    RETURN( ToLong( a ) > ToLong( b ) ? pc + d + 3 : pc + 4 );
}; break;

case vmc_gte_si: {
    long s = ToLong( pc[1] );
    Ref a = LOCAL( s );
    Ref b = pc[2];
    
    if ( not( IsSmall( a ) ) or not( IsSmall( b ) ) ) {
    	throw Mishap( "Small integers needed" );
    }
    
    long d = ToLong( pc[3] );
    RETURN( ToLong( a ) >= ToLong( b ) ? pc + d + 3: pc + 4 );
}; break;

case vmc_gte_ss: {
    long s = ToLong( pc[1] );
    long t = ToLong( pc[2] );
    
    Ref a = LOCAL( s );
    Ref b = LOCAL( t );
    
    if ( not IsSmall( a ) or not IsSmall( b ) ) {
    	throw Mishap( "Small integers only" );
    }
    
    long d = ToLong( pc[3] );
    RETURN( ToLong( a ) >= ToLong( b ) ? pc + d + 3 : pc + 4 );
}; break;

case vmc_halt: {
    #ifdef DBG_SPECIAL	
    printf( "\nhalt\n" );
    #endif
    fprintf( stderr, "Compilation error - fell off the end of a function\n" );
    exit( EXIT_FAILURE );
}; break;

case vmc_ifnot: {
    #ifdef DBG_SPECIAL
    fprintf( stderr, "IFNOT finds %x on the stack (cf. %x & %x)\n", (unt)(*( VMVP )), (unt)(SYS_FALSE), (unt)(SYS_TRUE) );
    #endif
    RETURN(
    	*( VMVP-- ) == SYS_FALSE ?
    	pc + ToLong( pc[ 1 ] ) + 1:
    	pc + 2
    );
}; break;

case vmc_ifso: {
    RETURN(
    	*( VMVP-- ) == SYS_FALSE ?
    	pc + 2 :
    	pc + ToLong( pc[ 1 ] ) + 1
    );
}; break;

case vmc_invoke: {
    //
    //	INVOKE only works as the 1st instruction of a function.
    //	It uses -ve offsets to access the fields before the key.
    //
    //	The purpose of INVOKE is to dispatch a core method on an
    //	object and its arguments.
    //
    
    //	Get the arity from the field before the function key.
    long A = ToLong( pc[ -2 ] );
    //	Check the arguments.
    if ( VMCOUNT != A ) {
    	enter_error( VMCOUNT, A );
    }
    
    //	Get the subject.
    Ref subject = VMVP[ A - 1 ];
    
    //	Get the method.
    //	Ref method = Ptr4ToRef( pc - 1 );	//	Self pointer (tagged) !!!!
    		
    //	Select the method fragment to call.
    if ( IsObj( subject ) ) {
    	Ref * subject_K = RefToPtr4( subject );
    	Ref key = subject_K[ 0 ];
    	
    	//	Does the method cache contain this key?
    	{
    		Ref method_table = pc[ 1 ];
    		while ( method_table != SYS_ABSENT ) {
    			Ref * entry_K = RefToPtr4( method_table );
    			if ( key == entry_K[ ASSOC_OFFSET_KEY ] ) {
    				Ref fn = entry_K[ ASSOC_OFFSET_VALUE ];
    				//	Now chain out.
    				Ref * fn_K = RefToPtr4( fn );
    				VMPCFUNC = fn_K;
    				RETURN( fn_K + 1 );
    			} else {
    				method_table = entry_K[ ASSOC_OFFSET_NEXT ];
    			}
    		}
    	}
    	
    	{
    		//	Ensure that there is enough room to add into the method
    		//	cache.
    		if ( vm->heap().wouldGC( ASSOC_SIZE ) ) {
    			vm->heap().preflight( pc, ASSOC_SIZE );
    			//	This will have trashed the local variables so we simply
    			//	retry! It's not efficient but it is exceedingly rare.
    			RETURN( pc );	//	<---- Loop!!
    		}
    	}
    	
    	//	Not in the method cache. Attempt to look it up in the method-table.
    	if ( IsObj( key ) ) {
    		//Ref * key_K = RefToPtr4( key );	
    		Ref dispatch_table = pc[2];
    		while ( dispatch_table != SYS_ABSENT ) {
    			Ref * entry_K = RefToPtr4( dispatch_table );
    			if ( key == entry_K[ ASSOC_OFFSET_KEY ] ) {	
    				Ref fn = entry_K[ ASSOC_OFFSET_VALUE ];
    				
    				//	Add to the method cache.
    				{
    					vm->gcVeto();
    					XfrClass xfr( vm->heap().preflight( pc, ASSOC_SIZE ) );
    					xfr.setOrigin();
    					xfr.xfrRef( sysAssocKey );
    					xfr.xfrRef( key );
    					xfr.xfrRef( fn );
    					xfr.xfrRef( pc[1] );	//	Reference to the current method table entry.
    					pc[1] = xfr.makeRef();
    					vm->gcLiftVeto();
    				}
    				
    				//	Now we chain into the fragment we have recovered, utilising the
    				//	fact that this is a lightweight call.
    				
    				Ref * fn_K = RefToPtr4( fn );
    				
    				//	Leave VMLINK & VMLINKFUNC alone.
    				//	The lite function has not stashed them into the callstack.
    				//	As a consequence we can chain directly without meddling with
    				//	them.
    				
    				VMPCFUNC = fn_K;
    				RETURN( fn_K + 1 );
    			} else {
    				dispatch_table = entry_K[ ASSOC_OFFSET_NEXT ];
    			}
    		}	
    		/* Failed to find a matching method */
    	}
    }
    invoke_error();
    RETURN( pc );	// IDIOT COMPILER. Only here to suppress daft complaints.
}; break;

case vmc_listiterate: {
    //	This instruction implements the fast iterator for lists.
    //	It may assume that there 2 items on the stack (L:List, _) on input.
    //	Since there were 2 inputs, it may therefore safely return 2 items
    //	without a stack check.
    
    Ref list = VMVP[-1];	//	Ignore VMVP[0], which is a dummy value.
    if ( IsPair( list ) ) {
    	VMVP[0] = RefToPtr4( list )[ PAIR_TAIL_OFFSET ];
    	VMVP[-1] = RefToPtr4( list )[ PAIR_HEAD_OFFSET ];
    } else {
    	VMVP[0] = SYS_TERMIN;	//	Signals exit.
    }
    
    
    VMPCFUNC = VMLINKFUNC;
    RETURN( VMLINK );
}; break;

case vmc_lt_si: {
    long s = ToLong( pc[1] );
    Ref a = LOCAL( s );
    Ref b = pc[2];
    
    if ( not( IsSmall( a ) ) or not( IsSmall( b ) ) ) {
    	throw Mishap( "Small integers needed" );
    }
    
    long d = ToLong( pc[3] );
    RETURN( ToLong( a ) < ToLong( b ) ? pc + d + 3 : pc + 4 );
}; break;

case vmc_lt_ss: {
    long s = ToLong( pc[1] );
    long t = ToLong( pc[2] );
    
    Ref a = LOCAL( s );
    Ref b = LOCAL( t );
    
    if ( not( IsSmall( a ) ) or not( IsSmall( b ) ) ) {
    	throw Mishap( "Small integers needed" );
    }
    
    long d = ToLong( pc[3] );
    RETURN( ToLong( a ) < ToLong( b ) ? pc + d + 3 : pc + 4 );
}; break;

case vmc_lte_si: {
    long s = ToLong( pc[1] );
    Ref a = LOCAL( s );
    Ref b = pc[2];
    
    if ( not( IsSmall( a ) ) or not( IsSmall( b ) ) ) {
    	throw Mishap( "Small integers needed" );
    }
    
    long d = ToLong( pc[3] );
    RETURN( ToLong( a ) <= ToLong( b ) ? pc + d + 3 : pc + 4 );
}; break;

case vmc_lte_ss: {
    long s = ToLong( pc[1] );
    long t = ToLong( pc[2] );
    Ref a = LOCAL( s );
    Ref b = LOCAL( t );
    
    if ( not( IsSmall( a ) ) or not( IsSmall( b ) ) ) {
    	throw Mishap( "Small integers needed" );
    }
    
    long d = ToLong( pc[3] );
    RETURN( ToLong( a ) <= ToLong( b ) ? pc + d + 3 : pc + 4 );
}; break;

case vmc_neq_si: {
    long s = ToLong( pc[1] );
    long i = ToLong( pc[2] );
    RETURN( ToLong( LOCAL( s ) ) == i ? pc + 4 : pc + ToLong( pc[3] ) + 3 );
}; break;

case vmc_neq_ss: {
    long s = ToLong( pc[1] );
    long t = ToLong( pc[2] );
    Ref a = LOCAL( s );
    Ref b = LOCAL( t );
    long d = ToLong( pc[3] );
    RETURN( a != b ? pc + d + 3 : pc + 4 );
}; break;

case vmc_not: {
    *VMVP = ( *VMVP == SYS_FALSE ? SYS_TRUE : SYS_FALSE );
    RETURN( pc + 1 );
}; break;

case vmc_pop_global: {
    Valof * id = (Valof *)( *( ++pc ) );
    id->valof = *( VMVP-- );
    RETURN( pc + 1 );
}; break;

case vmc_pop_local: {
    LOCAL( ToLong( *( ++pc ) ) ) = *( VMVP-- );
    RETURN( pc + 1 );
}; break;

case vmc_push_global: {
    Valof * id = (Valof *)( *( ++pc ) );
    if ( SYS_UNASSIGNED == ( *( ++VMVP ) = id->valof ) ) {
    	//	TO DO: Two problems here. Firstly it is not efficient to
    	//	do this check more than once. Secondly, the error message
    	//	does not supply enough context.
    	throw Mishap( "Accessing uninitialised variable" );
    }
    RETURN( pc + 1 );
}; break;

case vmc_push_local: {
    *( ++VMVP ) = LOCAL( ToLong( *( ++pc ) ) );
    RETURN( pc + 1 );
}; break;

case vmc_push_local0: {
    *( ++VMVP ) = LOCAL(0);
    RETURN( pc + 1 );
}; break;

case vmc_push_local1: {
    *( ++VMVP ) = LOCAL(1);
    RETURN( pc + 1 );
}; break;

case vmc_pushq: {
    *( ++VMVP ) = *( ++pc );
    RETURN( pc + 1 );
}; break;

case vmc_push_local_ret: {
    *( ++VMVP ) = LOCAL( ToLong( *( ++pc ) ) );
    Ref *linkptr;
    VMPCFUNC = ToRefRef( VMSP[ SP_FUNC ] );
    linkptr = ToRefRef( VMSP[ SP_LINK ] );				//	recover return address
    VMSP = ToRefRef( VMSP[ SP_PREV_SP ] );				//	restore stack pointer
    #ifdef DBG_SPECIAL
    	printf( "Recover link = %x\n", ToUInt( link ) );
    	printf( "Stack pointer recovered as %x\n", ToUInt( VMSP ) );
    #endif
    RETURN( linkptr );
}; break;

case vmc_push_local0_ret: {
    *( ++VMVP ) = LOCAL(0);
    Ref *linkptr;
    VMPCFUNC = ToRefRef( VMSP[ SP_FUNC ] );
    linkptr = ToRefRef( VMSP[ SP_LINK ] );				//	recover return address
    VMSP = ToRefRef( VMSP[ SP_PREV_SP ] );				//	restore stack pointer
    #ifdef DBG_SPECIAL
    	printf( "Recover link = %x\n", ToUInt( link ) );
    	printf( "Stack pointer recovered as %x\n", ToUInt( VMSP ) );
    #endif
    RETURN( linkptr );
}; break;

case vmc_push_local1_ret: {
    *( ++VMVP ) = LOCAL(1);
    Ref *linkptr;
    VMPCFUNC = ToRefRef( VMSP[ SP_FUNC ] );
    linkptr = ToRefRef( VMSP[ SP_LINK ] );				//	recover return address
    VMSP = ToRefRef( VMSP[ SP_PREV_SP ] );				//	restore stack pointer
    #ifdef DBG_SPECIAL
    	printf( "Recover link = %x\n", ToUInt( link ) );
    	printf( "Stack pointer recovered as %x\n", ToUInt( VMSP ) );
    #endif
    RETURN( linkptr );
}; break;

case vmc_pushq_ret: {
    *( ++VMVP ) = *( ++pc );
    Ref *linkptr;
    VMPCFUNC = ToRefRef( VMSP[ SP_FUNC ] );
    linkptr = ToRefRef( VMSP[ SP_LINK ] );				//	recover return address
    VMSP = ToRefRef( VMSP[ SP_PREV_SP ] );				//	restore stack pointer
    #ifdef DBG_SPECIAL
    	printf( "Recover link = %x\n", ToUInt( link ) );
    	printf( "Stack pointer recovered as %x\n", ToUInt( VMSP ) );
    #endif
    RETURN( linkptr );
}; break;

case vmc_reset: {
    FREEZE;
    throw NormalExit();
}; break;

case vmc_return: {
    Ref *linkptr;
    VMPCFUNC = ToRefRef( VMSP[ SP_FUNC ] );
    linkptr = ToRefRef( VMSP[ SP_LINK ] );				//	recover return address
    VMSP = ToRefRef( VMSP[ SP_PREV_SP ] );				//	restore stack pointer
    #ifdef DBG_SPECIAL
    	printf( "Recover link = %x\n", ToUInt( link ) );
    	printf( "Stack pointer recovered as %x\n", ToUInt( VMSP ) );
    #endif
    RETURN( linkptr );
}; break;

case vmc_return_ifso: {
    if( *( VMVP-- ) == SYS_FALSE ) {
    	RETURN( pc + 1 );									//	Go onto the next instruction.
    } else {
    	Ref *linkptr;
    	VMPCFUNC = ToRefRef( VMSP[ SP_FUNC ] );
    	linkptr = ToRefRef( VMSP[ SP_LINK ] );				//	Recover return address.
    	VMSP = ToRefRef( VMSP[ SP_PREV_SP ] );				//	Restore stack pointer.
    	RETURN( linkptr );
    }
}; break;

case vmc_return_ifnot: {
    if( *( VMVP-- ) != SYS_FALSE ) {
    	RETURN( pc + 1 );									//	Go onto the next instruction.
    } else {
    	Ref *linkptr;
    	VMPCFUNC = ToRefRef( VMSP[ SP_FUNC ] );
    	linkptr = ToRefRef( VMSP[ SP_LINK ] );				//	recover return address
    	VMSP = ToRefRef( VMSP[ SP_PREV_SP ] );				//	restore stack pointer
    	RETURN( linkptr );
    }
}; break;

case vmc_self_call: {
    {    
        VMLINK = pc + 1;
        VMLINKFUNC = VMPCFUNC;
        RETURN( VMPCFUNC + 1 );
    }
}; break;

case vmc_self_call_n: {
    VMCOUNT = ToLong( pc[ 1 ] );
    {    
        VMLINK = pc + 2;
        VMLINKFUNC = VMPCFUNC;
        RETURN( VMPCFUNC + 1 );
    }
}; break;

case vmc_self_constant: {
    *( ++VMVP ) = VMPCFUNC;
    RETURN( pc + 1 );
}; break;

case vmc_set: {
    VMCOUNT = VMVP - (Ref *)LOCAL( ToLong( pc[ 1 ] ) );
    RETURN( pc + 2 );
}; break;

case vmc_set_call_global: {
    Ref r = ((Valof *)( pc[ 2 ] )) -> valof;
    VMCOUNT = ToLong( pc[ 1 ] );
    {    
        Ref *ptr;
        if ( !IsObj( r ) ) call_error( r );
        ptr = RefToPtr4( r );
        if ( !IsFunctionKey( *ptr ) ) call_error( r );
        VMLINK = pc + 3;
        VMLINKFUNC = VMPCFUNC;
    	VMPCFUNC = ptr;
        RETURN( ptr + 1 );
    }
}; break;

case vmc_set_calls: {
    Ref r = *( VMVP-- );
    VMCOUNT = ToLong( pc[ 1 ] );
    {    
        Ref *ptr;
        if ( !IsObj( r ) ) call_error( r );
        ptr = RefToPtr4( r );
        if ( !IsFunctionKey( *ptr ) ) call_error( r );
        VMLINK = pc + 2;
        VMLINKFUNC = VMPCFUNC;
        VMPCFUNC = ptr;
        RETURN( ptr + 1 );
    }
}; break;

case vmc_set_syscall: {
    VMCOUNT = ToLong( pc[ 1 ] );
    SysCall * sys = ToSysCall( pc[ 2 ] );
    FREEZE;
    pc = (*sys)( pc + 3, vm );
    MELT;
    RETURN( pc );
}; break;

case vmc_start_mark: {
    long n = ToLong( *( ++pc ) );
    #ifdef DBG_SPECIAL
    fprintf( stderr, "Storing %u in %d\n", ToULong( ToRef( VMVP ) ), n );
    #endif
    LOCAL(n) = ToRef( VMVP );
    RETURN( pc + 1 );
}; break;

case vmc_stringiterate: {
    //	This instruction implements the fast iterator for vectors.
    //	It may assume that there 2 items on the stack (i:Small, v:Vector) on input.
    //	Since there were 2 inputs, it may therefore safely return 2 items
    //	without a stack check.
    
    Ref * string = RefToPtr4( VMVP[0] );
    Ref len_as_small = string[ STRING_OFFSET_LENGTH ];
    Ref index = VMVP[-1];
    
    //	Is is safe to compare smalls this way.
    if ( index < len_as_small ) {
    	VMVP[-1] = CharToCharacter( reinterpret_cast< unsigned char * >( string + 1 )[ SmallToLong( index ) ] );
    	VMVP[0] = ToRef( (long)index + (long)LongToSmall( 1 ) );			//	It is safe to add smalls like this too.
    } else {
    	VMVP[0]	= SYS_TERMIN;
    }
    
    VMPCFUNC = VMLINKFUNC;
    RETURN( VMLINK );
}; break;

case vmc_syscall: {
    SysCall * sys = ToSysCall( *++pc );
    FREEZE;
    pc = (*sys)( ++pc, vm );
    MELT;
    RETURN( pc );
}; break;

case vmc_syscall_arg: {
    SysCall * sys = ToSysCall( pc[ 1 ] );
    FREEZE;
    //	Skip the data arg. The system call picks it up via pc[-1]. Note that
    //	it is NOT garbage collected. That means it cannot be an object.
    pc = (*sys)( pc + 3, vm );
    MELT;
    RETURN( pc );
}; break;

case vmc_syscall_dat: {
    SysCall * sys = ToSysCall( pc[ 1 ] );
    FREEZE;
    //	Skip the data arg. The system call picks it up via pc[-1]. Note that
    //	it is NOT garbage collected. That means it cannot be an object.
    pc = (*sys)( pc + 3, vm );
    MELT;
    RETURN( pc );
}; break;

case vmc_syscall_argdat: {
    SysCall * sys = ToSysCall( pc[ 1 ] );
    FREEZE;
    //	Skip the data arg. The system call picks it up via pc[-1]. Note that
    //	it is NOT garbage collected. That means it cannot be an object.
    pc = (*sys)( pc + 4, vm );
    MELT;
    RETURN( pc );
}; break;

case vmc_sysreturn: {
    VMPCFUNC = VMLINKFUNC;
    RETURN( VMLINK );
}; break;

case vmc_vectoriterate: {
    //	This instruction implements the fast iterator for vectors.
    //	It may assume that there 2 items on the stack (i:Small, v:Vector) on input.
    //	Since there were 2 inputs, it may therefore safely return 2 items
    //	without a stack check.
    
    Ref * vector = RefToPtr4( VMVP[0] );
    Ref len_as_small = vector[ VECTOR_LAYOUT_OFFSET_LENGTH ];
    Ref index = VMVP[-1];
    
    //	Is is safe to compare smalls this way.
    if ( index > len_as_small ) {
    	VMVP[0]	= SYS_TERMIN;
    } else {
    	VMVP[-1] = vector[ SmallToLong( index ) ];
    	VMVP[0] = ToRef( (long)index + (long)LongToSmall( 1 ) );			//	It is safe to add smalls like this too.
    }
    
    VMPCFUNC = VMLINKFUNC;
    RETURN( VMLINK );
}; break;

case vmc_mixediterate: {
    //	This instruction implements the fast iterator for mixed record/vectors.
    //	It may assume that there 2 items on the stack (i:Small, v:Mixed) on input.
    //	Since there were 2 inputs, it may therefore safely return 2 items
    //	without a stack check.
    
    Ref * mixed = RefToPtr4( VMVP[0] );
    const int delta = LengthOfSimpleKey( *mixed );
    Ref len_as_small = AddSmall( mixed[ MIXED_LAYOUT_OFFSET_LENGTH ], LongToSmall( delta ) );
    Ref index = VMVP[-1];
    
    //	Is is safe to compare smalls this way.
    if ( index > len_as_small ) {
    	VMVP[0]	= SYS_TERMIN;
    } else {
    	VMVP[-1] = mixed[ SmallToLong( index ) + delta ];
    	VMVP[0] = AddSmall( index, LongToSmall( 1 ) );			//	It is safe to add smalls like this too.
    }
    
    VMPCFUNC = VMLINKFUNC;
    RETURN( VMLINK );
}; break;

