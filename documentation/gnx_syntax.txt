GinX: XML Transport Format for Ginger
=====================================
:Author:    Stephen Leach
:Email:     stephen.leach@steelypip.com
Created, June 2010
Revised, August 2010
Revised, May 2011


_Reader, please note that this is very much a work-in-progress. It is being written up as we design the relevant sections in appginger._

GinX Overview
-------------

The idea behind GinX (*.gnx) is to provide a representation of Ginger code that is neutral. But neutral we mean that it should be both human-readable and machine-friendly. Hence it should be easy for people with some computing background to understand the logic behind it, and easy for people to review but not necessarily write. It must also be easy for them to create programs, in their programming language of choice, that can read, transform and generate GinX. And it should be reasonably inexpensive to process, without that being an overriding consideration.

To balance these opposed concerns we borrowed from Lisp, especially Scheme. We selected a simplified subset of XML, called MinX. MinX is loosely based on s-expressions, which made programming very straightforward. We then designed the elements around Lisp-style primitives. This gave us a very clean design because we did not have to make concessions to programming convenience - because this is a representation that is essentially only written by machine, not people. 

There are disavantages to this approach, of course, such as it being relatively verbose and therefore slowing down compilation. Yet on the whole we believe GinX balances the relevant factors and is both effective and pleasing to use.


Element and Meta-attributes
---------------------------

Source File Attribute
~~~~~~~~~~~~~~~~~~~~~
Any element may have the optional 'source' that describes the source file (or
other source) of the element. It is a free-text string. It is considered to
apply to all nested nodes.

e.g.

    <bind source="hello.spi">
        <var name="helloWorld" protected="true/>
        <fn> ... </fn>
    </bind>

Span Attributes
~~~~~~~~~~~~~~~

Any element may have optional 'from' and 'to' attributes that describe the span 
of text of the source file that the element derives from. Each should have 
the format:
    
	(<digit>+)[.(<digit>+)] 
        
The first group specifies the row number and the second the column.
N.B. the column number is optional.

If the 'from' attribute is specified then the 'to' attribute will default
to the same line number as the 'from' attribute, although any column will
be ignored.

e.g.

	<app from="23.8" to="23.64"> .... </app>
    
Context Attribute
~~~~~~~~~~~~~~~~~

Any element may have the optional context attribute which will be printed
out to provide additional context. It will typically be a truncated version
of the spanned text.

Hint Attribute
~~~~~~~~~~~~~~

The optional hint attribute will be printed out to provide additional 
context on an error. As the name suggests, it should be phrased in such a 
way as to be a hint e.g. "Add type-checking".

Statements
----------

Syntax
~~~~~~

	STMNT ::=
		DECLARATION
		EXPR

Expressions
-----------

Syntax
~~~~~~

	EXPR ::=
		CONSTANT            ### any literal constant
		VARIABLE            ### reference to a variable
		ASSIGNMENT          ### assignment to a variable
		SEQ                 ### sequence of expressions (comma/semi separated)
		BLOCK               ### introduces a new scope
		FUNCTION            ### a function
		APP                 ### function application
		CONDITIONAL         ### if/unless
		LOOP                ### for loops
    

Constants
---------

Description
~~~~~~~~~~~

Constants are characterised by having a value attribute. Constants always
represent a single IMMUTABLE value. N.B. The compiler is free to share 
instances of these constants which are equal to each other. 

Syntax
~~~~~~

	CONSTANT ::=
		<absent value="absent"/>            ### The absent singleton
		<bool value=("true"|"false")/>      ### Booleans
		<int value=TEXT/>                   ### +/- arbitrary precision
		<float value=TEXT/>                 ### We might unify numbers?
		<string value=TEXT/>                ### Immutable strings
		<symbol value=TEXT/>                ### Symbols
		<char value=TEXT/>                  ### A single character
		<list value="empty"/>               ### Empty list, immutable
		<vector value="empty"/>             ### Empty vector, immutable
		<sysfn value=TEXT/>                 ### Named procedure
		<sysclass value=TEXT>               ### Named class

    
Examples
~~~~~~~~

	<int value="123"/>
	<float value="1.2"/>
	<string value="qwertyuiop"/>    
	<char value="A"/>
	<sysfn value="+"/>
    
N.B. Character sequences are multi-valued constants. They are represented as
a sequence of characters.

	<seq><char value="a"/><char value="b"/><char value="c"/></seq>
    

Available Named Procedures
~~~~~~~~~~~~~~~~~~~~~~~~~~

Note that these constants are not necessarily bound to identifiers in Ginger. 
These constants are intended as direct support for built-in operators (e.g.
arithmetic) and syntactic forms such as list construction, string interpolation, 
etc.

	<sysfn value="+"/>                  ### }
	<sysfn value="-"/>                  ### }
	<sysfn value="*"/>                  ### }- standard arithmetic
	<sysfn value="/"/>                  ### }
	<sysfn value="**"/>                 ### }
	<sysfn value="..."/>                ### Equivalent to explode
	<sysfn value="headList"/>
	<sysfn value="isEmptyList"/>
	<sysfn value="newList"/>
	<sysfn value="newVector"/>
	<sysfn value="newMap"/>             
	<sysfn value="newSet"/>
	<sysfn value="newBag"/>
	<sysfn value="not"/>                ### Boolean negation
	<sysfn value="tailList"/>
	<sysfn value="!!"/>                 ### Absent negation
    
N.B. There may be implementation-extensions to this list, it is not intended
to be exhaustive.  

N.B. It is intended that all the members of this list are guaranteed to be
available from the "std" package. Hence they are functionally equivalent to
<id name=NAME pkg="std"/>

See also the 'sysapp' element. 

Available Named Classes
~~~~~~~~~~~~~~~~~~~~~~~

There is a built-in class for every type of built-in value, although they are
not necessarily bound to identifiers in Ginger.

	<sysclass value="Absent"/>          ### class for absent
	<sysclass value="Bool"/>            ### class for true & false
	<sysclass value="SmallInt"/>        ### class for 'small' integers
	<sysclass value="Float"/>           ### class for floats
	<sysclass value="String"/>          ### class for strings
	<sysclass value="Char"/>            ### class for characters
	<sysclass value="Nil"/>             ### class for nil
	<sysclass value="Pair"/>            ### class for list pairs
	<sysclass value="Vector"/>          ### class for vectors
	<sysclass value="Fn"/>              ### class for function objects
	<sysclass value="Class"/>           ### class for classes

Note that classes are not exactly he same as types. All function objects share
the same class but may have entirely different types.

    
Variable Reference
------------------

Notes: We have to add in name qualification e.g. nicknames. We also should consider
a way of allocating local variables guaranteed never to clash with local
variables created by the programmer. Maybe have an extra hidden dimension on 
names??

Note: there are three ways by which a global variable might be referred by.
 1.	A qualified reference, using the alias attribute
 2.	An unqualified reference, using the enc.pkg (enclosing package) attribute
 3.	An absolute reference, using the def.pkg (defining package) attribute
 5.1	Syntax


	VARIABLE ::=
		<id name=NAME 
			[enc.pkg=PACKAGE_NAME ]
			[def.pkg=PACKAGE_NAME | alias=NICKNAME	 ]
		/>

    
    
Assignments
-----------

Description
~~~~~~~~~~~
N.B. Assignment runs from left-to-right, not following the usual convention. The destination expression may be a complex assignable expression.

Syntax
~~~~~~

	<set> SRC_EXPR DST_EXPR </set>

Sequences & Blocks
------------------

Overview
~~~~~~~~

Sequences are used to create a sequence of expressions. Blocks are sequences with the additional property that they introduce a new scope. 

Syntax
~~~~~~

	SEQ ::=
		<seq> EXPR* </seq>
	BLOCK ::=
		<block> EXPR* </block>

    
Function Applications
---------------------

Syntax
~~~~~~

	APP ::=
		<app> EXPR EXPR </app>       
		<sysapp name=NAME> EXPR* </sysapp> 
                                            
Comment by kers – it might be useful to distinguish the LHS and RHS arguments to a function call (if only for reporting/debugging).

SysApps
~~~~~~~

REVISE!

SysApp's are efficient variants of standard function calls. 
They typically place serious restrictions on the pre-conditions
and failing to satisfy those preconditions may corrupt the
system (i.e. is undefined behaviour). This is the place where 
it is necessary for users to read the small-print 
on what the restrictions for correct use. N.B. They play the same
role as Pop-11's fast operations.) 

In return for , the user entitled to assume the call do their 
job as efficiently as they can reasonably be made.

In support of this, the devteam is authorised to make reasonable 
assumptions to help performance e.g. the call may be inlined, 
computed at compile-time, overflow checking may be deferred 
until the end of the parent block, no debug information may
be available, the garbage collector may be blocked, and so on. 

For all the built-in sysfns there is a corresponding safe routine
(which appear in package 'std'). A correct program must work when
any 'sysapp' is replaced by an 'app' to the safe routine. e.g.

	### Best performance but may be undefined if the 
	### preconditions are not met.
	<sysapp name="foo"> ... </sysapp> 
		
	### Has well-defined failure mode but will do the same
	### as the sysapp if the preconditions are met.
	<app><id name="foo" pkg="sys"/><seq>...</seq></app>

SysApp's are guaranteed to exist for every sysfn and vice
versa. Unlike sysapp's, sysfns are not guaranteed to be
efficient but may be implemented behind the scenes as
an function that invokes the sysapp.

	### permitted possible implementation of sysfn called 'foo' 
	<fn title="foo">
		<explode><var name=”x”/></explode>
		<sysapp name="foo">
			<explode><id name=”x”/></explode>
		</sysapp>
	</fn>

This highlights that the entitlement to efficiency is only
assured for direct calls.
    

Such a form may silently be transformed into a relatively 
inefficient form such as the one below. 

	<fn>
		<explode><var name=”x”/></explode>
		<sysapp name="foo"><explode><id name=”x”/></explode></sysapp>
	</fn>

However it is guaranteed that direct calls of sysfns will
be as efficient as sysapps.

	### This form will be treated as identical to
	### the one below. (The reverse is not true.)
	<app><sysfn value="foo"/> ... </app> turns into
	<sysapp name="foo"> ... </sysapp>


Examples of SysApp's
~~~~~~~~~~~~~~~~~~~~

e.g.

	f( x ) turns into
	<app><id name="f"/><id name="x"/></app>
    
	[ 1, 2, 3 ] turns into
	<sysapp name="newList">
		<int value="1"/>
		<int value="2"/>
		<int value="3"/>
	</sysapp>
    

Conditionals
------------

Notes: In progress - I am designing these as multi-part if/then/elseif/../else/endif
forms. This means they are an easy target for compiling switches. Short
circuits need to be fleshed out.

Syntax
~~~~~~

	CONDITIONAL ::=
		<if> ( IF_PART THEN_PART )*  [ELSE_PART] </if>
		<and> EXPR* </and>
		<or> EXPR* </or>
		<abs-and> EXPR* </abs-and>                          ### &&
		<abs-or> EXPR* </abs-or>                            ### ||
		
	IF_PART ::= EXPR
	THEN_PART ::= EXPR
	ELSE_PART ::= EXPR



For Loops
---------

Notes: This is work in progress. Easier to understand if declarations come first.

Syntax
~~~~~~

	LOOP ::= <for> QUERY STMNTS </for>
		
	QUERY ::= 
		<bind> PATTERN EXPR </bind>
		<from> PATTERN FROM_EXPR TO_EXPR </from>
		<in> PATTERN EXPR </in>



Declarations and Patterns 
-------------------------

Overview
~~~~~~~~

Declarations match a pattern with an expression - patterns being limited 
expressions that contain pattern variables. N.B. The intention is to fit
this to the pattern/query proposal.

	<bind>
		PATTERN
		EXPR
	</bind>

Syntax
~~~~~~

	<bind>
		PATTERN
		EXPR
	</bind>

A PATTERN is any of the following

	PATTERN ::= PATTERN_VAR | PATTERN_SEQ | PATTERN_APP | PATTERN_CONST
		
	PATTERN_VAR ::=
		<var 
			name=NAME 
			[(match|type)=TYPE_EXPR] 
			[protected=BOOL] 
			[enc.pkg=PACKAGE_NAME]
			[def.pkg=PACKAGE_NAME |
			 qualifier=ALIAS_NAME ]
			( (tag0|tag1|..)=TAG_VALUE )* 
		/>

Comment! Qualifier or alias?

	PATTERN_SEQ ::=
		<seq> PATTERN* </seq>
			
	PATTERN_CONST ::=
		EXPR
	
	PATTERN_APP ::=
		<app> EXPR PATTERN </app>
        

Pattern Variables
~~~~~~~~~~~~~~~~~

These are the most basic and familiar types of pattern. They introduce an optionally typed variable. The protected attribute plays the same role as in Pop-11, protecting the variable from assignment (n.b. this is shallow rather than deep protection.)

name=NAME::
The "name" attribute is optional. If it is omitted then it is an anonymous variable.

type=TYPE_EXPR::
The type-check will be made BEFORE assignment  and a failed type-check will generate an error.

match=TYPE_EXPR::        
The type-check is made BEFORE the assignment and failure will cause the matcher to backtrack.

protected=BOOL::
If “true” variable is protected against subsequent  assignments. Generated by val and define declarations. If “false” the variable may be assigned to. If omitted the default is “true”.

Top level variables may also be given tags and package qualifiers. 

tagN=TAG_VALUE::
Tags the variable.

qualifier=ALIAS::         
The name is qualified by an import alias.

pkg=PACKAGE_NAME::        
The package name is an absolute reference to a package.

Comment! Qualifier or alias!

Note: we also need to cope with forward declarations.

As a Query
~~~~~~~~~~

A declaration is a type of query that either fails or succeeds once. 
In particular this loop would execute once:

	<for>
		<bind>
			<var name="foo"/>
			<absent value="absent"/>
		</bind>
		STATEMENTS
	</for>


Examples
~~~~~~~~
        
		
	### Note that var/val introduces a query in Ginger. The '=' operator
	### is a query operator whose LHS is a pattern. Identifiers are
	### parsed as pattern-variables within a pattern, taking on the
	### default protection of the var/val.
	var x = 99;
	<bind><var name="x"/><int value="99"/></bind>
		
	### The identifiers can given overrides for protection or type.
	val [ x, var y, z : bool ] = f();
	<bind>
		<app>
			<id name="newList">
			<seq>
				<var name="x" protected="true"/>
				<var name="y" protected="false"/>
				<var name="z" type="bool" protected="true"/>
			</seq>
		</app>
		<app><id name="f"/></app>
	</bind>
		
	### Ensure that p returns a single value which is an integer.
	val _ : int = p();      
	<bind>
		<var type="int" protected="true"/>
		<app><id name="p"/></app>       
	</bind>
		
	### The 'define' form also introduces an implicit PATTERN = EXPR
	### bindings where EXPR will be the arguments to the function.
	define K( x )( y ) => x enddefine;
	<bind><var name="K"/><fn name="K"><var name="x"/><fn><var name="y"/><id name="x"/></fn></fn></bind>
		

Packages and Imports
--------------------

Overview
~~~~~~~~

The package element introduces a new package. Packages should be named uniquely via URIs. Items within the package are compiled with the new package as the default.

If a package attempts to introduce a pre-existing package, the action taken depends on whether or not appginger is in development-mode (reloaded allowed) or in run-mode (reloading forbidden).

The import element establishes a relationship between two packages. This relationship is used to make top-level variables visible from other packages. 

Syntax
~~~~~~

	PACKAGE ::=
		<package url=PACKAGE_URL>
			IMPORT*
			STMNT*
		</package>
	
	IMPORT ::=
		<import 
			from=PACKAGE_URL
			( (match0|match1|...)=TAG_VALUE )*
			[ alias=ALIAS_NAME ]
			[ qualified=("true"|"false") ]
			[ protected=("true"|"false") ]
			( ( into0|into1|...)=TAG_VALUE )*
		/>
    
Package
~~~~~~~
The package element introduces a named package. Packages have to be uniquely named and we suggest URLs are used to achieve this. As always, this is advisory.

The top-level variables of the statements within that package are resolved with respect to that package. Resolution is the process of mapping a top-level name into a corresponding, anonymous runtime-record called a variable.

Package are essentially local maps from names to variables. Packages are chained together by imports, so that resolving a name in one package may yield a name in the local map or any imported package.

Imports
~~~~~~~
The import element is a named connection between two packages. Once an import is established, resolving a name in the importing package may continue into the imported package. 

The import utilizes tagging to restrict the variables that are searched. Variables that are searched due to an import are said to be exported. The match attributes specifies which variables are exported from the imported package, only those with matching tags may be exported.
The import is named by the alias attribute. Aliases must be unique within a package. The alias is used to qualify a variable reference e.g. myalias::myvariable. This is also affected by the qualified attribute which specifies whether or not a search in this import must use the alias. 

By default, imports are not qualified.

The protected attribute specifies whether or not the import may be masked by local declarations. If an import is protected then every declaration in the package must be checked to ensure it would not mask (or shadow) an imported variable. By default, imports are not protected.
The into attribute specifies whether or not the exported variables are re-exported by the importing package. If the into attribute is provided then it specifies which tag(s) they will be re-exported under. If it is not provided then there is no re-export.



