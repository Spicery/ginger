%{
#include <string>
using namespace std;

#include "functor.hpp"
#include "item.hpp"
#include "key.hpp"
#include "special.hpp"
#include "role.hpp"
//  Special constants to help with regular text layout.
#define Clo CloserRole
#define PrF PrefixRole
#define PoF PostfixRole
#define BoF BothfixRole
#define Imm ImmediateRole
#define POp PrefixOpRole
#define BOp BinaryOpRole
#define SOp SuffixOpRole
#define InL InLineRole

static ItemClass item_default_struct =
    {
        "<default>",       //  name
        fnc___fnc_default,   //  functor
        PrefixRole,
        0,
        0
    };
ItemClass * item_default = &item_default_struct;

static ItemClass item_unary_op_struct =
    {
        "<default>",       //  name
        fnc___fnc_default,   //  functor
        PrefixRole,
        0,
        0
    };
ItemClass * item_unary_op = &item_unary_op_struct;

static ItemClass item_binary_op_struct =
    {
        "<default>",        //  name
        fnc___fnc_default,  //  functor
        PrefixRole,
        0,
        0
    };
ItemClass * item_binary_op = &item_binary_op_struct;

bool item_is_neg_num( Item it ) {
    return(
        it->functor == fnc_int &&
        SmallToInt( it->extra ) < 0
    );
}

int item_int( Item it ) {
    return ToInt( it->extra );
}

bool item_is_prefix( Item it ) {
    return IsPrefix( it->role );
}

bool item_is_postfix( Item it ) {
    return IsPostfix( it->role );
}

bool item_is_anyfix( Item it ) {
    return IsAnyfix( it->role );
}

bool item_is_binary( Item it ) {
    return IsBinary( it->role );
}

%}
ItemClass { const char *name; enum Functor functor; enum Role role; int precedence; Ref extra };
%%
!!#             fnc_absnot,         POp,  prec_not,       0
&&#             fnc_absand,         BOp,  1700,           0
(#              fnc_oparen,         BoF,  100,            0
)#              fnc_cparen,         Clo,  0,              0
*#              fnc_mul,            BOp,  400,            0
**#             fnc_pow,            BOp,  300,            0
+#              fnc_add,            BOp,  600,            0
++#             fnc_append,         BOp,  800,            0
,#              fnc_comma,          BOp,  prec_comma,     0
-#              fnc_sub,            BOp,  700,            0
.#              fnc_dot,            PoF,  200,            0
/#              fnc_div,            BOp,  500,            0
:=#             fnc_assign,         BOp,  2000,           0
;#              fnc_semi,           PoF,  prec_semi,      0
<#              fnc_lt,             BOp,  1200,           0
<=#             fnc_lte,            BOp,  1400,           0
=#              fnc_eq,             BOp,  1100,           0
==#             fnc_eq,             BOp,  1000,           0
=>#             fnc_arrow,          BOp,  prec_arrow,     0
>#              fnc_gt,             BOp,  1300,           0
>=#             fnc_gte,            BOp,  1500,           0
??#             fnc_present,        PoF,  1900,           0
@#              fnc_at,             PoF,  900,            0
[#              fnc_obracket,       PrF,  100,            0
]#              fnc_cbracket,       Clo,  0,              0
_print#         fnc__print,         InL,  0,              &spc__print
_putchar#       fnc__putchar,       InL,  0,              &spc__putchar
absent#         fnc_absent,         Imm,  0,              sys_absent
and#            fnc_and,            BOp,  1700,           0
const#          fnc_const,          PrF,  0,              0
define#         fnc_define,         PrF,  0,              0
do#             fnc_do,             PrF,  0,              0
else#           fnc_else,           PrF,  0,              0
elseif#         fnc_elseif,         PrF,  0,              0
elseunless#     fnc_elseunless,     PrF,  0,              0
enddefine#      fnc_enddefine,      PrF,  0,              0
endfn#          fnc_endfn,          PrF,  0,              0
endfor#         fnc_endfor,         PrF,  0,              0
endif#          fnc_endif,          PrF,  0,              0
endunless#      fnc_endunless,      PrF,  0,              0
false#          fnc_false,          Imm,  0,              sys_false
fn#             fnc_fn,             PrF,  0,              0
for#            fnc_for,            PrF,  0,              0
if#             fnc_if,             PrF,  0,              0
not#            fnc_not,            POp,  prec_not,       0
or#             fnc_or,             BOp,  1800,           0
then#           fnc_then,           PrF,  0,              0
true#           fnc_true,           Imm,  0,              sys_true
unless#         fnc_unless,         PrF,  0,              0
until#          fnc_until,          PrF,  0,              0
var#            fnc_var,            PrF,  0,              0
while#          fnc_while,          PrF,  0,              0
{#              fnc_obrace,         PrF,  100,            0
||#             fnc_absor,          BOp,  1800,           0
}#              fnc_cbrace,         PoF,  0,              0
